#!/usr/bin/env python
"""
Provides Claude with immediate project context on session start.
Runs: git status, recent commits, directory structure snapshot.
Uses virtual environment python from uv, not system python3.
"""
import json
import os
import subprocess
import sys
import traceback
from pathlib import Path

def get_repo_root():
    """Get git repository root directory"""
    print(f"üîç [session-start] Getting repo root from: {os.getcwd()}", file=sys.stderr)
    result = subprocess.run(
        ["git", "rev-parse", "--show-toplevel"],
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        raise Exception(f"git rev-parse failed: {result.stderr}")
    root = Path(result.stdout.strip())
    print(f"üîç [session-start] Repo root: {root}", file=sys.stderr)
    return root

def get_git_status():
    """Get current git status"""
    try:
        result = subprocess.run(
            ["git", "status", "--short"],
            capture_output=True,
            text=True
        )
        return result.stdout
    except Exception as e:
        print(f"‚ö†Ô∏è  [session-start] ERROR in get_git_status: {e}", file=sys.stderr)
        return f"ERROR: {e}"

def get_recent_commits():
    """Get last 5 commits in oneline format"""
    try:
        result = subprocess.run(
            ["git", "log", "--oneline", "-5"],
            capture_output=True,
            text=True
        )
        return result.stdout
    except Exception as e:
        print(f"‚ö†Ô∏è  [session-start] ERROR in get_recent_commits: {e}", file=sys.stderr)
        return f"ERROR: {e}"

def get_key_directories():
    """Generate directory tree with file counts and key indicators"""
    try:
        project_root = get_repo_root()

        # Directories to ignore
        ignore_dirs = {'.git', '.venv', 'node_modules', '__pycache__', '.task',
                      '.ruff_cache', '.pytest_cache', 'site', '.wsl-rootfs-cache',
                      'Users'}

        structure = []

        # Get all top-level directories
        top_level_dirs = sorted([
            d for d in project_root.iterdir()
            if d.is_dir() and d.name not in ignore_dirs and not d.name.startswith('.')
        ])

        for dir_path in top_level_dirs:
            # Count files and get key info
            all_files = list(dir_path.rglob("*"))
            file_count = len([f for f in all_files if f.is_file()])

            # Detect key file types
            indicators = []
            exts = {}
            for f in all_files:
                if f.is_file():
                    ext = f.suffix.lower()
                    if ext:
                        exts[ext] = exts.get(ext, 0) + 1

            # Highlight important file types
            if exts.get('.md', 0) > 0:
                indicators.append(f"{exts['.md']} md")
            if exts.get('.py', 0) > 0:
                indicators.append(f"{exts['.py']} py")
            if exts.get('.sh', 0) > 0:
                indicators.append(f"{exts['.sh']} sh")
            if exts.get('.go', 0) > 0:
                indicators.append(f"{exts['.go']} go")
            if exts.get('.yml', 0) + exts.get('.yaml', 0) > 0:
                indicators.append(f"{exts.get('.yml', 0) + exts.get('.yaml', 0)} yml")

            # Check for key files
            key_files = []
            if (dir_path / "Taskfile.yml").exists():
                key_files.append("Taskfile")
            if (dir_path / "README.md").exists():
                key_files.append("README")
            if (dir_path / "go.mod").exists():
                key_files.append("go.mod")

            info = f"{dir_path.name}/ ({file_count} files"
            if indicators:
                info += f": {', '.join(indicators)}"
            if key_files:
                info += f" | {', '.join(key_files)}"
            info += ")"

            structure.append(info)

        return "\n".join(f"  {item}" for item in structure)

    except Exception as e:
        print(f"‚ö†Ô∏è  [session-start] ERROR in get_key_directories: {e}", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        return "ERROR: Could not generate directory structure"

def get_pending_changelog():
    """Check for pending changelog entries"""
    try:
        project_root = get_repo_root()
        pending_file = project_root / ".pending-changelog"

        if not pending_file.exists():
            return None

        pending_entries = []
        with open(pending_file, 'r') as f:
            for line in f:
                if line.strip():
                    parts = line.strip().split('|')
                    if len(parts) == 3:
                        pending_entries.append({
                            "hash": parts[0],
                            "message": parts[1],
                            "date": parts[2]
                        })

        return pending_entries if pending_entries else None
    except Exception as e:
        print(f"‚ö†Ô∏è  [session-start] ERROR in get_pending_changelog: {e}", file=sys.stderr)
        return None

def main():
    try:
        print(f"üîç [session-start] Starting from: {os.getcwd()}", file=sys.stderr)

        hook_input = json.loads(sys.stdin.read())
        print(f"üîç [session-start] Hook input cwd: {hook_input.get('cwd', 'N/A')}", file=sys.stderr)

        context = {
            "git_status": get_git_status(),
            "recent_commits": get_recent_commits(),
            "directory_structure": get_key_directories(),
            "pending_changelog": get_pending_changelog(),
            "cwd": hook_input["cwd"]
        }

        # Format as markdown for Claude
        output = f"""
## üìÅ Project Context (Auto-loaded)

**Git Status:**
```
{context['git_status']}
```

**Recent Commits:**
```
{context['recent_commits']}
```

**Directory Structure:**
```
{context['directory_structure']}
```
"""

        # Add pending changelog reminder if entries exist
        if context['pending_changelog']:
            count = len(context['pending_changelog'])
            output += f"\n\n‚ö†Ô∏è **Pending Changelog Updates ({count} commits):**\n```\n"
            for entry in context['pending_changelog']:
                output += f"{entry['date']} [{entry['hash']}] {entry['message']}\n"
            output += "```\n"
            if count >= 3:
                output += "\n‚ùó **Action Required**: Next commit will be blocked until changelog is updated.\n"
            else:
                output += f"\nüìù Reminder: Will block at 3 commits (currently {count}/3)\n"

        print(f"‚úÖ [session-start] Complete", file=sys.stderr)

        # Return as system message
        print(json.dumps({
            "continue": True,
            "systemMessage": output.strip()
        }))

    except Exception as e:
        error_details = traceback.format_exc()
        print(f"‚ö†Ô∏è  [session-start] EXCEPTION: {e}", file=sys.stderr)
        print(f"‚ö†Ô∏è  [session-start] Traceback:\n{error_details}", file=sys.stderr)

        # Never block - return error as system message
        error_msg = f"\n‚ö†Ô∏è **Session Start Hook Error**\n\n```\n{str(e)}\n\nWorking directory: {os.getcwd()}\n```\n\n*Hook continuing anyway...*\n"
        print(json.dumps({
            "continue": True,
            "systemMessage": error_msg
        }))

if __name__ == "__main__":
    main()

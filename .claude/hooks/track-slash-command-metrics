#!/usr/bin/env python3
"""
PostToolUse hook to track slash command metrics.
Triggers after SlashCommand tool completes.
"""
import json
import sys
import os
import re
from datetime import datetime
from pathlib import Path

# Add metrics library to path
sys.path.insert(0, str(Path(__file__).parent.parent / "lib"))
from metrics import create_base_entry, write_metric


def parse_logsift_output(output: str) -> dict:
    """
    Parse logsift command output to extract metrics.

    Logsift outputs YAML format like:
    summary:
      status: success
      exit_code: 0
      duration_seconds: 1.023
      log_file: "/path/to/log"
    stats:
      total_errors: 0
      total_warnings: 0

    Returns dict with:
    - duration_seconds
    - exit_code
    - errors_found
    - warnings_found
    - log_file
    """
    metrics = {
        "duration_seconds": None,
        "exit_code": None,
        "errors_found": 0,
        "warnings_found": 0,
        "log_file": None
    }

    try:
        # Parse YAML-style output using regex
        # Extract duration_seconds (float)
        duration_match = re.search(r'duration_seconds:\s*([\d.]+)', output)
        if duration_match:
            metrics["duration_seconds"] = float(duration_match.group(1))

        # Extract exit_code (int)
        exit_code_match = re.search(r'exit_code:\s*(-?\d+)', output)
        if exit_code_match:
            metrics["exit_code"] = int(exit_code_match.group(1))

        # Extract log_file (quoted string)
        log_file_match = re.search(r'log_file:\s*"([^"]+)"', output)
        if log_file_match:
            metrics["log_file"] = log_file_match.group(1)

        # Extract error/warning counts from stats section
        errors_match = re.search(r'total_errors:\s*(\d+)', output)
        if errors_match:
            metrics["errors_found"] = int(errors_match.group(1))

        warnings_match = re.search(r'total_warnings:\s*(\d+)', output)
        if warnings_match:
            metrics["warnings_found"] = int(warnings_match.group(1))

    except Exception as e:
        print(f"‚ö†Ô∏è Failed to parse logsift output: {e}", file=sys.stderr)

    return metrics


def extract_slash_command_info(tool_input: dict, tool_output: str) -> dict | None:
    """
    Extract metrics from slash command execution.

    Returns metric entry dict or None if not a tracked command.
    """
    command = tool_input.get("command", "")

    # Only track logsift commands
    if not command.startswith("/logsift"):
        return None

    # Determine command type
    is_auto = command.startswith("/logsift-auto")
    metric_type = "logsift-auto" if is_auto else "logsift"

    # Parse logsift output
    logsift_metrics = parse_logsift_output(tool_output)

    # Extract command details
    if is_auto:
        # /logsift-auto "natural language description"
        nl_input_match = re.search(r'/logsift-auto\s+"([^"]+)"', command)
        nl_input = nl_input_match.group(1) if nl_input_match else command[13:].strip()

        # Try to find interpreted command from output
        cmd_match = re.search(r'Command:\s*(.+?)(?:\n|$)', tool_output)
        interpreted_cmd = cmd_match.group(1).strip() if cmd_match else "unknown"

        return {
            "command": "/logsift-auto",
            "natural_language_input": nl_input,
            "interpreted_command": interpreted_cmd,
            "parsing_successful": interpreted_cmd != "unknown",
            **logsift_metrics
        }
    else:
        # /logsift "actual command" [timeout]
        parts = command[8:].strip().split()  # Remove "/logsift"

        # Extract command (quoted string)
        cmd_match = re.search(r'"([^"]+)"', command)
        underlying_cmd = cmd_match.group(1) if cmd_match else "unknown"

        # Extract timeout (optional number after command)
        timeout = None
        if len(parts) > 1:
            try:
                timeout = int(parts[-1])
            except ValueError:
                pass

        return {
            "command": "/logsift",
            "full_command": command,
            "underlying_command": underlying_cmd,
            "timeout_minutes": timeout,
            **logsift_metrics
        }


def main():
    try:
        # Read hook input
        hook_input = json.loads(sys.stdin.read())

        session_id = hook_input.get("session_id", "unknown")
        tool_name = hook_input.get("tool_name")
        tool_input = hook_input.get("tool_input", {})
        tool_output = hook_input.get("tool_output", "")

        # Only track SlashCommand tool
        if tool_name != "SlashCommand":
            sys.exit(0)

        # Extract command info
        command_info = extract_slash_command_info(tool_input, tool_output)

        if not command_info:
            # Not a tracked command
            sys.exit(0)

        # Create metric entry
        entry = create_base_entry(session_id, command_info.pop("command").replace("/", ""))
        entry.update(command_info)

        # Write metric
        if write_metric(entry):
            print(f"üìä Logged {entry['type']} metrics", file=sys.stderr)

    except Exception as e:
        # Never block - just log error
        print(f"‚ö†Ô∏è Slash command metrics tracking failed: {e}", file=sys.stderr)

    sys.exit(0)


if __name__ == "__main__":
    main()

#!/usr/bin/env python3
"""
PreToolUse hook for Task tool (commit-agent subagent).
Automatically enhances commit agent prompts with git context.

Injects:
- File list (staged or unstaged)
- File count
- Inferred change type (docs/feat/fix/chore/test)
- Complexity assessment (simple/complex)
- Staging status

This saves the commit agent from running git status/diff to discover files.
"""
import json
import sys
import subprocess
from pathlib import Path


def get_git_status():
    """Get changed files from git status."""
    try:
        result = subprocess.run(
            ["git", "status", "--short"],
            capture_output=True,
            text=True,
            cwd=Path.cwd(),
            timeout=2
        )

        if result.returncode != 0:
            return None

        lines = [line for line in result.stdout.strip().split('\n') if line]
        if not lines:
            return None

        staged = []
        unstaged = []

        for line in lines:
            status = line[:2]
            filepath = line[3:].strip()

            if filepath.endswith('/'):
                continue

            if status[0] != ' ' and status[0] != '?':
                staged.append(filepath)
            if status[1] != ' ':
                unstaged.append(filepath)
            if status == '??':
                unstaged.append(filepath)

        return {
            'staged': staged,
            'unstaged': unstaged,
            'all': list(set(staged + unstaged))
        }
    except Exception:
        return None


def infer_change_type(files):
    """Infer change type from file paths and extensions."""
    if not files:
        return "unknown"

    extensions = set(Path(f).suffix for f in files)
    paths_lower = [f.lower() for f in files]

    if any('.github' in p or '.gitlab' in p or 'ci' in p for p in paths_lower):
        return "ci"

    if any('test' in p or 'spec' in p for p in paths_lower):
        return "test"

    if extensions <= {'.md', '.txt', '.rst', '.adoc'}:
        return "docs"

    if extensions <= {'.yml', '.yaml', '.json', '.toml', '.ini', '.conf', '.cfg'}:
        return "chore"

    if extensions <= {'.sh', '.bash', '.zsh'}:
        return "chore"

    if extensions & {'.py', '.js', '.ts', '.go', '.rs', '.rb', '.java', '.cpp', '.c', '.lua'}:
        return "feat/fix"

    return "mixed"


def respond_allow(updated_fields, reason="Pass through"):
    """Output the correct PreToolUse hook response format."""
    response = {
        "hookSpecificOutput": {
            "hookEventName": "PreToolUse",
            "permissionDecision": "allow",
            "permissionDecisionReason": reason,
            "updatedInput": updated_fields
        }
    }
    print(json.dumps(response))
    sys.exit(0)


def main():
    try:
        hook_input = json.loads(sys.stdin.read())
        tool_input = hook_input.get("tool_input", {})

        if tool_input.get("subagent_type") != "commit-agent":
            respond_allow({}, "Not a commit-agent")

        git_status = get_git_status()
        if not git_status or not git_status['all']:
            respond_allow({}, "No git changes")

        if not git_status['staged']:
            respond_allow({}, "No staged files")

        files = git_status['staged']
        change_type = infer_change_type(files)
        file_count = len(files)
        complexity = "simple" if file_count <= 3 else "complex"

        if file_count <= 10:
            file_list = ", ".join(files)
        else:
            file_list = ", ".join(files[:10]) + f" (and {file_count - 10} more)"

        current_prompt = tool_input.get("prompt", "")

        context_header = f"""Git Context (auto-injected by hook):
Files (already staged): {file_list}
File count: {file_count}
Inferred type: {change_type}
Complexity: {complexity}

Original request: {current_prompt}"""

        updated_input = dict(tool_input)
        updated_input["prompt"] = context_header
        respond_allow(updated_input, "Enhanced with git context")

    except Exception as e:
        print(f"⚠️  enhance-commit-context hook error (non-blocking): {e}", file=sys.stderr)
        respond_allow({}, f"Error: {e}")


if __name__ == "__main__":
    main()

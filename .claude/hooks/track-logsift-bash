#!/usr/bin/env python3
"""
PostToolUse hook to track logsift metrics from Bash tool execution.
Triggers after Bash tool completes if command contains 'logsift monitor'.
"""
import json
import sys
import re
from pathlib import Path

# Add metrics library to path
sys.path.insert(0, str(Path(__file__).parent.parent / "lib"))
from metrics import create_base_entry, write_metric


def parse_logsift_bash_output(output: str, command: str) -> dict | None:
    """
    Parse logsift output from Bash tool execution.

    Returns metric dict or None if not a logsift command.
    """
    # Only process if this is a logsift command
    if "logsift monitor" not in command:
        return None

    metrics = {
        "duration_seconds": None,
        "exit_code": None,
        "errors_found": 0,
        "warnings_found": 0,
        "log_file": None
    }

    try:
        # Parse YAML-style output
        duration_match = re.search(r'duration_seconds:\s*([\d.]+)', output)
        if duration_match:
            metrics["duration_seconds"] = float(duration_match.group(1))

        exit_code_match = re.search(r'exit_code:\s*(-?\d+)', output)
        if exit_code_match:
            metrics["exit_code"] = int(exit_code_match.group(1))

        log_file_match = re.search(r'log_file:\s*"([^"]+)"', output)
        if log_file_match:
            metrics["log_file"] = log_file_match.group(1)

        errors_match = re.search(r'total_errors:\s*(\d+)', output)
        if errors_match:
            metrics["errors_found"] = int(errors_match.group(1))

        warnings_match = re.search(r'total_warnings:\s*(\d+)', output)
        if warnings_match:
            metrics["warnings_found"] = int(warnings_match.group(1))

    except Exception as e:
        print(f"‚ö†Ô∏è Failed to parse logsift bash output: {e}", file=sys.stderr)
        return None

    return metrics


def extract_underlying_command(bash_command: str) -> str:
    """Extract the actual command being monitored by logsift."""
    # Pattern: logsift monitor -- <command>
    match = re.search(r'logsift monitor\s+--\s+(.+)', bash_command)
    if match:
        return match.group(1).strip()
    return "unknown"


def main():
    try:
        # Read hook input
        hook_input = json.loads(sys.stdin.read())

        session_id = hook_input.get("session_id", "unknown")
        tool_name = hook_input.get("tool_name")
        tool_input = hook_input.get("tool_input", {})
        tool_output = hook_input.get("tool_output", "")

        # Only track Bash tool
        if tool_name != "Bash":
            sys.exit(0)

        bash_command = tool_input.get("command", "")

        # Parse logsift output
        logsift_metrics = parse_logsift_bash_output(tool_output, bash_command)

        if not logsift_metrics:
            # Not a logsift command or parsing failed
            sys.exit(0)

        # Create metric entry
        entry = create_base_entry(session_id, "logsift")
        entry["command"] = "/logsift"
        entry["underlying_command"] = extract_underlying_command(bash_command)
        entry.update(logsift_metrics)

        # Write metric
        if write_metric(entry):
            print(f"üìä Logged logsift metrics from Bash", file=sys.stderr)

    except Exception as e:
        # Never block - just log error
        print(f"‚ö†Ô∏è Logsift bash metrics tracking failed: {e}", file=sys.stderr)

    sys.exit(0)


if __name__ == "__main__":
    main()

#!/usr/bin/env bash
# ================================================================== #
# UNIVERSAL SYMLINK MANAGER
# Replaces GNU Stow with a flexible symlink system
# ================================================================== #

set -euo pipefail

DOTFILES_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_header() {
    echo -e "${CYAN}=== $1 ===${NC}"
}

# Function to create symlinks from source directory to target directory
create_symlinks() {
    local source_dir="$1"
    local target_dir="$2"
    local description="$3"

    log_header "$description"

    if [[ ! -d "$source_dir" ]]; then
        log_error "Source directory does not exist: $source_dir"
        return 1
    fi

    log_info "Creating symlinks from $source_dir to $target_dir"

    # Find all files and symlinks in source and create symlinks, excluding certain paths
    find "$source_dir" \( -type f -o -type l \) | while read -r file; do
        # Get relative path from source directory
        relative_path="${file#$source_dir/}"

        # Skip files in excluded directories
        if [[ "$relative_path" == *"tmux/plugins/"* ]] || \
           [[ "$relative_path" == *".tmux/plugins/"* ]] || \
           [[ "$relative_path" == *".git/"* ]]; then
            continue
        fi

        # Target path
        target_path="$target_dir/$relative_path"

        # Create parent directory for file
        mkdir -p "$(dirname "$target_path")"

        # Create symlink using ln -sf
        ln -sf "$file" "$target_path"
        log_success "Linked: $relative_path"
    done
}

# Function to remove symlinks from a directory
remove_symlinks() {
    local target_dir="$1"
    local description="$2"

    log_header "Removing symlinks from $description"

    if [[ ! -d "$target_dir" ]]; then
        log_warning "Target directory does not exist: $target_dir"
        return 0
    fi

    local count=0
    local removed_links=()

    # Collect symlinks that point to our dotfiles directory
    while IFS= read -r symlink; do
        if [[ -L "$symlink" ]]; then
            local target="$(readlink "$symlink")"
            # Only remove symlinks that point to our DOTFILES_DIR
            if [[ "$target" == "$DOTFILES_DIR"* ]]; then
                removed_links+=("$symlink")
            fi
        fi
    done < <(find "$target_dir" -type l 2>/dev/null)

    # Remove the collected symlinks
    for symlink in "${removed_links[@]}"; do
        if [[ -L "$symlink" ]]; then
            rm "$symlink"
            relative_path="${symlink#$target_dir/}"
            log_success "Removed: $relative_path"
            count=$((count + 1))
        fi
    done

    if [[ $count -eq 0 ]]; then
        log_info "No dotfiles symlinks found to remove"
    else
        log_info "Removed $count dotfiles symlinks"
    fi

    # Remove empty directories
    find "$target_dir" -type d -empty -delete 2>/dev/null || true

    log_info "Cleanup: Removed empty directories"
}

# Function to show symlinks in a directory
show_symlinks() {
    local target_dir="$1"
    local description="$2"
    local source_pattern="${3:-}"

    log_header "Symlinks in $description"

    if [[ ! -d "$target_dir" ]]; then
        log_warning "Directory does not exist: $target_dir"
        return 0
    fi

    local symlinks_found=false
    local search_cmd="find '$target_dir' -maxdepth 3 -type l"

    # If we have a source pattern, filter by it
    if [[ -n "$source_pattern" ]]; then
        while IFS= read -r symlink; do
            if [[ -L "$symlink" ]]; then
                local target="$(readlink "$symlink")"
                if [[ "$target" == "$source_pattern"* ]]; then
                    symlinks_found=true
                    local relative_path="${symlink#$target_dir/}"
                    echo "  $relative_path -> $target"
                fi
            fi
        done < <(eval "$search_cmd" 2>/dev/null)
    else
        while IFS= read -r symlink; do
            symlinks_found=true
            local target="$(readlink "$symlink")"
            local relative_path="${symlink#$target_dir/}"
            echo "  $relative_path -> $target"
        done < <(eval "$search_cmd" 2>/dev/null | head -20)  # Limit to first 20 for performance
    fi

    if [[ "$symlinks_found" == "false" ]]; then
        log_info "No symlinks found"
    fi
}

# Function to handle 'shared' command - symlink shared to platform directories
handle_shared() {
    local action="$1"
    local shared_dir="$DOTFILES_DIR/shared"

    # Hardcoded list of valid platform directories
    local valid_platforms=("macos" "wsl" "ubuntu" "arch")

    case "$action" in
        "link"|"create")
            log_header "Symlinking shared configuration to platform directories"

            # Link to only the valid platform directories
            for platform in "${valid_platforms[@]}"; do
                local platform_dir="$DOTFILES_DIR/$platform"
                if [[ -d "$platform_dir" ]]; then
                    create_symlinks "$shared_dir" "$platform_dir" "Shared -> $platform"
                else
                    log_warning "Platform directory does not exist: $platform_dir"
                fi
            done
            ;;
        "unlink"|"remove")
            log_header "Removing shared symlinks from platform directories"

            for platform in "${valid_platforms[@]}"; do
                local platform_dir="$DOTFILES_DIR/$platform"
                if [[ -d "$platform_dir" ]]; then
                    local count=0
                    local removed_links=()

                    # Collect all shared symlinks first
                    while IFS= read -r symlink; do
                        if [[ -L "$symlink" ]]; then
                            local target="$(readlink "$symlink")"
                            if [[ "$target" == "$shared_dir"* ]]; then
                                removed_links+=("$symlink")
                            fi
                        fi
                    done < <(find "$platform_dir" -type l 2>/dev/null)

                    # Now remove the collected symlinks
                    for symlink in "${removed_links[@]}"; do
                        rm "$symlink"
                        local relative_path="${symlink#$platform_dir/}"
                        log_success "Removed shared symlink from $platform: $relative_path"
                        count=$((count + 1))
                    done

                    if [[ $count -eq 0 ]]; then
                        log_info "No shared symlinks found in $platform"
                    fi

                    # Remove empty directories
                    find "$platform_dir" -type d -empty -delete 2>/dev/null || true
                fi
            done
            ;;
        "show")
            for platform in "${valid_platforms[@]}"; do
                local platform_dir="$DOTFILES_DIR/$platform"
                if [[ -d "$platform_dir" ]]; then
                    echo ""
                    log_header "Shared symlinks in $platform"
                    find "$platform_dir" -type l | while read -r symlink; do
                        if [[ "$(readlink "$symlink")" == "$shared_dir"* ]]; then
                            local target="$(readlink "$symlink")"
                            local relative_path="${symlink#$platform_dir/}"
                            echo "  $relative_path -> $target"
                        fi
                    done
                fi
            done
            ;;
    esac
}

# Function to handle platform commands - symlink platform directory to $HOME
handle_platform() {
    local platform="$1"
    local action="$2"
    local platform_dir="$DOTFILES_DIR/$platform"

    case "$action" in
        "link"|"create")
            create_symlinks "$platform_dir" "$HOME" "$platform -> \$HOME"
            ;;
        "unlink"|"remove")
            # Only remove symlinks that point to this platform's dotfiles directory
            log_header "Removing $platform symlinks from \$HOME"

            if [[ ! -d "$HOME" ]]; then
                log_warning "Home directory does not exist: $HOME"
                return 0
            fi

            local count=0
            local removed_links=()

            # Collect all symlinks first, then process them
            while IFS= read -r symlink; do
                if [[ -L "$symlink" ]]; then
                    local target="$(readlink "$symlink")"
                    if [[ "$target" == "$platform_dir"* ]]; then
                        removed_links+=("$symlink")
                    fi
                fi
            done < <(find "$HOME" -maxdepth 3 -type l 2>/dev/null)

            # Now remove the collected symlinks
            for symlink in "${removed_links[@]}"; do
                if [[ -L "$symlink" ]]; then
                    rm "$symlink"
                    local relative_path="${symlink#$HOME/}"
                    log_success "Removed: $relative_path"
                    count=$((count + 1))
                fi
            done

            if [[ $count -eq 0 ]]; then
                log_info "No $platform symlinks found to remove"
            else
                log_info "Removed $count symlinks"
            fi

            log_info "Cleanup: Finding and removing empty directories"
            find "$HOME" -maxdepth 3 -type d -empty -delete 2>/dev/null || true
            ;;
        "show")
            show_symlinks "$HOME" "\$HOME ($platform symlinks)" "$platform_dir"
            ;;
    esac
}

# Function to show usage
show_usage() {
    echo "Usage: $0 <target> [action]"
    echo ""
    echo "Targets:"
    echo "  shared           - Manage symlinks from shared/ to platform directories"
    echo "                     (Supports: macos, wsl, ubuntu, arch)"
    echo "  <platform>       - Manage symlinks from platform directory to \$HOME"
    echo "                     (Any directory in the dotfiles root)"
    echo ""
    echo "Actions (default: link):"
    echo "  link, create     - Create symlinks"
    echo "  unlink, remove   - Remove symlinks"
    echo "  show             - Show current symlinks"
    echo ""
    echo "Examples:"
    echo "  $0 shared                    # Link shared/ to supported platform dirs"
    echo "  $0 shared link               # Same as above"
    echo "  $0 shared unlink             # Remove shared symlinks from platforms"
    echo "  $0 shared show               # Show shared symlinks"
    echo ""
    echo "  $0 macos                     # Link macos/ to \$HOME"
    echo "  $0 macos link                # Same as above"
    echo "  $0 macos unlink              # Remove macos symlinks from \$HOME"
    echo "  $0 macos show                # Show macos symlinks in \$HOME"
    echo ""
    echo "  $0 wsl                       # Link wsl/ to \$HOME"
    echo "  $0 mint                      # Link mint/ to \$HOME (if mint/ exists)"
    echo ""
    echo "Supported platforms for 'shared' command: macos, wsl, ubuntu, arch"
    echo ""
    echo "Available directories:"
    for dir in "$DOTFILES_DIR"/*; do
        if [[ -d "$dir" && "$(basename "$dir")" != "shared" && "$(basename "$dir")" != ".git" ]]; then
            echo "  - $(basename "$dir")"
        fi
    done
}

# Main function
main() {
    local target="${1:-}"
    local action="${2:-link}"

    if [[ -z "$target" ]]; then
        show_usage
        exit 1
    fi

    case "$target" in
        "shared")
            handle_shared "$action"
            ;;
        "-h"|"--help"|"help")
            show_usage
            ;;
        *)
            # Check if it's a valid platform directory
            if [[ -d "$DOTFILES_DIR/$target" ]]; then
                handle_platform "$target" "$action"
            else
                log_error "Unknown target or directory does not exist: $target"
                echo ""
                show_usage
                exit 1
            fi
            ;;
    esac
}

main "$@"

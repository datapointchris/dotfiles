#!/usr/bin/env bash
# ================================================================== #
# UNIVERSAL SYMLINK MANAGER
# Cross-platform dotfiles symlink management with layered architecture
# ================================================================== #

set -euo pipefail

# Configuration
readonly DOTFILES_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SEARCH_DEPTH=3
readonly CLEANUP_DIRECTORIES=("$HOME/.config" "$HOME/.local" "$HOME/.shell" "$HOME/.setup-macos")

# Colors for logging
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m'

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_header() {
    echo -e "${CYAN}=== $1 ===${NC}"
}

# Helper function to resolve symlink target to absolute path
resolve_symlink_target() {
    local symlink="$1"
    local target
    target="$(readlink "$symlink")"
    local symlink_dir
    symlink_dir="$(dirname "$symlink")"

    if [[ "$target" = /* ]]; then
        # Already absolute path
        echo "$target"
    else
        # Relative path - convert to absolute
        cd "$symlink_dir" && realpath "$target" 2>/dev/null || echo ""
    fi
}

# Helper function to check if a file should be excluded from symlinking
should_exclude_file() {
    local relative_path="$1"
    local filename
    filename="$(basename "$relative_path")"

    # Exclude patterns
    [[ "$relative_path" == *"tmux/plugins/"* ]] || \
    [[ "$relative_path" == *".tmux/plugins/"* ]] || \
    [[ "$relative_path" == *".git/"* ]] || \
    [[ "$filename" == ".DS_Store" ]] || \
    [[ "$filename" == "Thumbs.db" ]] || \
    [[ "$filename" == "desktop.ini" ]] || \
    [[ "$filename" == *.tmp ]] || \
    [[ "$filename" == *.temp ]] || \
    [[ "$filename" == *.log ]] || \
    [[ "$filename" == *.cache ]] || \
    [[ "$filename" == *.swap ]] || \
    [[ "$filename" == *.swp ]] || \
    [[ "$filename" == *~ ]] || \
    [[ "$relative_path" == *"node_modules/"* ]] || \
    [[ "$relative_path" == *".venv/"* ]] || \
    [[ "$relative_path" == *"__pycache__/"* ]] || \
    [[ "$filename" == *.pyc ]] || \
    [[ "$relative_path" == *".pytest_cache/"* ]]
}

# Helper function to clean up empty directories
cleanup_empty_directories() {
    local target_dir="$1"

    if [[ "$target_dir" == "$HOME" ]]; then
        # Only clean up specific directories we know we created, with limited depth
        for cleanup_dir in "${CLEANUP_DIRECTORIES[@]}"; do
            if [[ -d "$cleanup_dir" ]]; then
                find "$cleanup_dir" -maxdepth "$SEARCH_DEPTH" -type d -empty -delete 2>/dev/null || true
            fi
        done
        log_info "Cleanup: Removed empty directories from config areas"
    else
        # For non-HOME directories, safe to clean more aggressively
        find "$target_dir" -type d -empty -delete 2>/dev/null || true
        log_info "Cleanup: Removed empty directories"
    fi
}

# Function to create symlinks from source directory to target directory
create_symlinks() {
    local source_dir="$1"
    local target_dir="$2"
    local description="$3"

    log_header "$description"

    if [[ ! -d "$source_dir" ]]; then
        log_error "Source directory does not exist: $source_dir"
        return 1
    fi

    log_info "Creating symlinks from $source_dir to $target_dir"

    # Find all files and symlinks in source and create symlinks
    find "$source_dir" \( -type f -o -type l \) | while read -r file; do
        # Get relative path from source directory
        local relative_path="${file#"$source_dir"/}"

        # Skip files that shouldn't be symlinked
        if should_exclude_file "$relative_path"; then
            log_info "Skipping: $relative_path (excluded file type)"
            continue
        fi

        # Target path
        local target_path="$target_dir/$relative_path"

        # Create parent directory for file
        mkdir -p "$(dirname "$target_path")"

        # Calculate relative path from target back to source
        local target_parent_dir
        target_parent_dir="$(dirname "$target_path")"
        local relative_symlink_path
        relative_symlink_path="$(python3 -c "
import os
print(os.path.relpath('$file', '$target_parent_dir'))
")"

        # Create symlink using relative path
        ln -sf "$relative_symlink_path" "$target_path"
        log_success "Linked: $relative_path -> $relative_symlink_path"
    done
}

# Function to remove symlinks from a directory
remove_symlinks() {
    local target_dir="$1"
    local description="$2"
    local source_filter="${3:-}"

    log_header "Removing symlinks from $description"

    if [[ ! -d "$target_dir" ]]; then
        log_warning "Target directory does not exist: $target_dir"
        return 0
    fi

    local count=0
    local removed_links=()

    # Collect symlinks that point to our dotfiles directory (or specific source if provided)
    while IFS= read -r symlink; do
        if [[ -L "$symlink" ]]; then
            local absolute_target
            absolute_target="$(resolve_symlink_target "$symlink")"

            # Filter by specific source directory if provided, otherwise any dotfiles symlink
            local should_remove=false
            if [[ -n "$source_filter" ]]; then
                # Only remove symlinks that point to the specific source directory
                if [[ -n "$absolute_target" && "$absolute_target" == "$source_filter"* ]]; then
                    should_remove=true
                fi
            else
                # Remove any symlinks that point to our DOTFILES_DIR
                if [[ -n "$absolute_target" && "$absolute_target" == "$DOTFILES_DIR"* ]]; then
                    should_remove=true
                fi
            fi

            if [[ "$should_remove" == true ]]; then
                removed_links+=("$symlink")
            fi
        fi
    done < <(find "$target_dir" -maxdepth "$SEARCH_DEPTH" -type l 2>/dev/null)

    # Remove the collected symlinks
    for symlink in "${removed_links[@]}"; do
        if [[ -L "$symlink" ]]; then
            rm "$symlink"
            local relative_path="${symlink#"$target_dir"/}"
            log_success "Removed: $relative_path"
            count=$((count + 1))
        fi
    done

    if [[ $count -eq 0 ]]; then
        log_info "No dotfiles symlinks found to remove"
    else
        log_info "Removed $count dotfiles symlinks"
    fi

    cleanup_empty_directories "$target_dir"
}

# Function to show symlinks in a directory
show_symlinks() {
    local target_dir="$1"
    local description="$2"
    local source_pattern="${3:-}"

    log_header "Symlinks in $description"

    if [[ ! -d "$target_dir" ]]; then
        log_warning "Directory does not exist: $target_dir"
        return 0
    fi

    local symlinks_found=false
    local broken_count=0

    # Find and display symlinks
    while IFS= read -r symlink; do
        if [[ -L "$symlink" ]]; then
            local target
            target="$(readlink "$symlink")"

            # If we have a source pattern, filter by it
            if [[ -n "$source_pattern" ]]; then
                local absolute_target
                absolute_target="$(resolve_symlink_target "$symlink")"

                if [[ -n "$absolute_target" && "$absolute_target" == "$source_pattern"* ]]; then
                    symlinks_found=true
                    local relative_path="${symlink#"$target_dir"/}"

                    # Check if the symlink is broken
                    if [[ ! -e "$symlink" ]]; then
                        echo -e "  ${RED}$relative_path -> $target${NC} (BROKEN)"
                        broken_count=$((broken_count + 1))
                    else
                        echo "  $relative_path -> $target"
                    fi
                fi
            else
                symlinks_found=true
                local relative_path="${symlink#"$target_dir"/}"

                # Check if the symlink is broken
                if [[ ! -e "$symlink" ]]; then
                    echo -e "  ${RED}$relative_path -> $target${NC} (BROKEN)"
                    broken_count=$((broken_count + 1))
                else
                    echo "  $relative_path -> $target"
                fi
            fi
        fi
    done < <(find "$target_dir" -maxdepth "$SEARCH_DEPTH" -type l 2>/dev/null | head -20)

    if [[ "$symlinks_found" == "false" ]]; then
        log_info "No symlinks found"
    elif [[ $broken_count -gt 0 ]]; then
        echo ""
        log_warning "$broken_count broken symlinks detected"
        log_info "Run '$0 check $2' to manage broken symlinks"
    fi
}

# Function to handle 'common' command - symlink common directly to $HOME
handle_common() {
    local action="$1"
    local common_dir="$DOTFILES_DIR/common"

    case "$action" in
        "link"|"create")
            create_symlinks "$common_dir" "$HOME" "Common -> \$HOME (base layer)"
            ;;
        "unlink"|"remove")
            remove_symlinks "$HOME" "\$HOME (common base layer)" "$common_dir"
            ;;
        "show")
            show_symlinks "$HOME" "\$HOME (common base layer)" "$common_dir"
            ;;
        "check")
            check_dangling_symlinks "$HOME"
            ;;
        *)
            log_error "Unknown action for common: $action"
            return 1
            ;;
    esac
}

# Function to handle platform commands - symlink platform directory to $HOME
handle_platform() {
    local action="$1"
    local platform="$2"
    local platform_dir="$DOTFILES_DIR/$platform"

    # Check if the platform directory exists
    if [[ ! -d "$platform_dir" ]]; then
        log_error "Platform directory does not exist: $platform_dir"
        exit 1
    fi

    case "$action" in
        "link"|"create")
            create_symlinks "$platform_dir" "$HOME" "$platform -> \$HOME (overlay layer)"
            ;;
        "unlink"|"remove")
            remove_symlinks "$HOME" "\$HOME ($platform overlay layer)" "$platform_dir"
            ;;
        "show")
            show_symlinks "$HOME" "\$HOME ($platform overlay layer)" "$platform_dir"
            ;;
        "check")
            check_dangling_symlinks "$HOME"
            ;;
        "overlay")
            log_header "Creating platform overlay: $platform -> \$HOME"
            create_symlinks "$platform_dir" "$HOME" "$platform -> \$HOME (overlay layer)"
            ;;
        *)
            log_error "Unknown action for platform $platform: $action"
            return 1
            ;;
    esac
}

# Function to handle relink - performs complete relink of a platform
handle_relink() {
    local target="$1"

    log_header "Relink - Complete $target Environment Refresh"
    log_info "This will refresh your entire $target environment with 5 steps:"
    log_info "1. Remove current $target symlinks"
    log_info "2. Remove common base layer symlinks"
    log_info "3. Check for dangling symlinks"
    log_info "4. Create common base layer"
    log_info "5. Create $target overlay layer"
    echo
    log_info "Step 1: Removing existing $target symlinks..."
    handle_platform "unlink" "$target"

    echo ""
    log_info "Step 2: Removing existing common symlinks..."
    handle_common "unlink"

    echo ""
    log_info "Step 3: Checking for dangling symlinks..."
    check_dangling_symlinks

    echo ""
    log_info "Step 4: Creating common base layer..."
    handle_common "link"

    echo ""
    log_info "Step 5: Creating $target overlay layer..."
    handle_platform "link" "$target"

    echo ""
    log_success "Relink complete! $target is now fully refreshed."
}

# Function to detect and optionally remove dangling symlinks
check_dangling_symlinks() {
    local specific_dir="${1:-}"
    local dangling_links=()
    local link_count=0

    if [[ -n "$specific_dir" ]]; then
        log_info "Scanning for dangling symlinks in $specific_dir..."
    else
        log_info "Scanning for dangling symlinks in \$HOME..."
    fi

    local search_path="${specific_dir:-$HOME}"

    # Find symlinks that point to dotfiles but are broken
    while IFS= read -r symlink_path; do
        if [[ -L "$symlink_path" ]]; then
            local target
            target="$(readlink "$symlink_path")"
            local symlink_dir
            symlink_dir="$(dirname "$symlink_path")"

            # Resolve relative path to absolute if needed
            local absolute_target
            if [[ "$target" = /* ]]; then
                # Already absolute path
                absolute_target="$target"
            else
                # Relative path - convert to absolute by resolving from symlink's directory
                absolute_target="$(cd "$symlink_dir" && realpath -m "$target" 2>/dev/null)"
            fi

            # Check if it points to our dotfiles but the target doesn't exist
            if [[ -n "$absolute_target" && "$absolute_target" == "$DOTFILES_DIR"* && ! -e "$absolute_target" ]]; then
                dangling_links+=("$symlink_path")
                link_count=$((link_count + 1))
            fi
        fi
    done < <(find "$search_path" -maxdepth "$SEARCH_DEPTH" -type l 2>/dev/null)

    if [[ $link_count -eq 0 ]]; then
        log_success "No dangling dotfiles symlinks found"
        return 0
    else
        log_warning "Found $link_count dangling dotfiles symlinks:"
        for symlink_path in "${dangling_links[@]}"; do
            local relative_path="${symlink_path#"$search_path"/}"
            local target_path="$(readlink "$symlink_path")"
            echo "  $relative_path -> $target_path"
        done

        echo ""
        log_info "Auto-removing dangling symlinks..."
        for symlink_path in "${dangling_links[@]}"; do
            rm "$symlink_path"
            local relative_path="${symlink_path#"$search_path"/}"
            log_success "Removed dangling symlink: $relative_path"
        done
        cleanup_empty_directories "$search_path"
        log_info "Cleaned up empty directories"
        return $link_count
    fi
}

# Function to show usage
show_usage() {
    echo "Usage: $0 <action> <target>"
    echo ""
    echo "LAYERED ARCHITECTURE:"
    echo "  Base Layer:   common/ -> \$HOME      (shared configs for all platforms)"
    echo "  Overlay Layer: platform/ -> \$HOME   (platform-specific overrides)"
    echo ""
    echo "Actions:"
    echo "  link, create     - Create symlinks"
    echo "  unlink, remove   - Remove symlinks"
    echo "  show             - Show current symlinks (broken links highlighted in red)"
    echo "  check            - Check for and automatically remove broken symlinks"
    echo "  overlay          - Create platform overlay (alias for link)"
    echo "  relink           - Complete refresh: unlink platform, unlink common,"
    echo "                     check dangling symlinks, link common, link platform"
    echo ""
    echo "Targets:"
    echo "  common           - Manage base layer: common/ directly to \$HOME"
    echo "  <platform>       - Manage overlay layer: platform/ to \$HOME"
    echo "                     (Any directory in the dotfiles root)"
    echo ""
    echo "RECOMMENDED WORKFLOW:"
    echo "  1. $0 link common            # Create base layer (common -> \$HOME)"
    echo "  2. $0 link macos             # Add platform overlay (macos -> \$HOME)"
    echo ""
    echo "MAINTENANCE:"
    echo "  $0 relink macos              # Complete refresh of macos setup"
    echo "  $0 check macos               # Check for broken symlinks only"
    echo ""
    echo "Examples:"
    echo "  $0 link common               # Link common/ directly to \$HOME (base layer)"
    echo "  $0 unlink common             # Remove common symlinks from \$HOME"
    echo "  $0 show common               # Show common symlinks in \$HOME"
    echo "  $0 check common              # Check for broken symlinks in \$HOME (auto-removes them)"
    echo ""
    echo "  $0 link macos                # Link macos/ to \$HOME (overlay layer)"
    echo "  $0 overlay macos             # Same as above (explicit overlay)"
    echo "  $0 unlink macos              # Remove macos symlinks from \$HOME"
    echo "  $0 show macos                # Show macos symlinks in \$HOME"
    echo "  $0 check macos               # Check for broken symlinks in \$HOME (auto-removes them)"
    echo ""
    echo "  $0 relink macos              # Complete refresh of macos (recommended for maintenance)"
    echo "  $0 link wsl                  # Link wsl/ to \$HOME (overlay layer)"
    echo ""
    echo "Available directories:"
    for dir in "$DOTFILES_DIR"/*; do
        if [[ -d "$dir" && "$(basename "$dir")" != "common" && "$(basename "$dir")" != ".git" ]]; then
            echo "  - $(basename "$dir")"
        fi
    done
    echo ""
    echo "NOTE: Platform overlays will overwrite common configs where conflicts exist."
    echo "NOTE: Relink will detect and offer to remove dangling symlinks during refresh."
    echo "NOTE: The 'show' command highlights broken symlinks in red."
    echo "NOTE: The 'check' command automatically removes broken symlinks without confirmation."
}

# Main function
main() {
    local action="${1:-}"
    local target="${2:-}"

    if [[ -z "$action" ]]; then
        show_usage
        exit 1
    fi

    # Handle help
    if [[ "$action" == "-h" || "$action" == "--help" || "$action" == "help" ]]; then
        show_usage
        exit 0
    fi

    # Handle relink action
    if [[ "$action" == "relink" ]]; then
        if [[ -z "$target" ]]; then
            log_error "Relink requires a platform name. Usage: $0 relink <platform>"
            exit 1
        fi
        if [[ ! -d "$DOTFILES_DIR/$target" ]]; then
            log_error "Platform directory does not exist: $target"
            exit 1
        fi
        handle_relink "$target"
        return 0
    fi

    # Handle standard actions (link, unlink, show, etc.)
    if [[ -z "$target" ]]; then
        log_error "Action '$action' requires a target. Usage: $0 <action> <target>"
        echo ""
        show_usage
        exit 1
    fi

    case "$target" in
        "common")
            handle_common "$action"
            ;;
        "shared")
            log_warning "The 'shared' command has been renamed to 'common'. Please use 'common' instead."
            handle_common "$action"
            ;;
        *)
            # Check if it's a valid platform directory
            if [[ -d "$DOTFILES_DIR/$target" ]]; then
                handle_platform "$action" "$target"
            else
                log_error "Unknown target or directory does not exist: $target"
                echo ""
                show_usage
                exit 1
            fi
            ;;
    esac
}

main "$@"

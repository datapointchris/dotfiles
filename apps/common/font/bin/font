#!/usr/bin/env bash
# Font management - built on tested library
# fzf integration layer on top of font library

set -euo pipefail

# Source the library (handle symlinks)
SCRIPT_PATH="${BASH_SOURCE[0]:-$0}"
if [[ -L "$SCRIPT_PATH" ]]; then
  # Get absolute path of symlink target
  SCRIPT_PATH="$(python3 -c "import os; print(os.path.realpath('$SCRIPT_PATH'))")"
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
FONT_APP_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

# Source formatting library for colorized help
if [[ -f "$HOME/shell/formatting.sh" ]]; then
  source "$HOME/shell/formatting.sh"
elif [[ -f "$HOME/dotfiles/platforms/common/shell/formatting.sh" ]]; then
  source "$HOME/dotfiles/platforms/common/shell/formatting.sh"
fi

source "$FONT_APP_DIR/lib/lib.sh"
source "$FONT_APP_DIR/lib/storage.sh"

# Config file locations
GHOSTTY_CONFIG="$HOME/.config/ghostty/config"
NVIM_FONT_CONFIG="$HOME/.config/nvim/lua/config/font.lua"

usage() {
  # Check if formatting functions are available
  if command -v print_header &>/dev/null; then
    print_header "Font Testing & Management" "cyan"
    echo "Data-driven font tracking with automatic rankings"
    echo ""

    print_section "Commands" "blue"
    cat <<'EOF'
  current              Show currently active font
  change               Interactive font picker with previews
  apply <font>         Apply font to Ghostty/Neovim (auto-logs)
  like [message]       Like current font with optional reason
  dislike [message]    Dislike current font with optional reason
  note <message>       Add note to current font (message required)
  random               Apply random font from all available fonts
  rank                 Show fonts ranked by likes/dislikes
  log                  View complete history
  list                 List all available font families
  generate-previews    Pre-generate all preview images
  clear-cache          Clear preview cache
EOF

    print_section "Examples" "yellow"
    if command -v print_cyan &>/dev/null; then
      echo "  $(print_cyan "font change")                         # Interactive picker"
      echo "  $(print_cyan "font like \"Great ligatures\"")         # Like with reason"
      echo "  $(print_cyan "font dislike \"Too wide\"")             # Dislike with reason"
      echo "  $(print_cyan "font note \"Good for prose\"")          # Add note"
      echo "  $(print_cyan "font rank")                            # See rankings"
      echo "  $(print_cyan "font log")                             # View history"
    else
      cat <<'EOF'
  font change                         # Interactive picker
  font like "Great ligatures"         # Like with reason
  font dislike "Too wide"             # Dislike with reason
  font note "Good for prose"          # Add note
  font rank                           # See rankings
  font log                            # View history
EOF
    fi

    print_section "Data Storage" "green"
    cat <<'EOF'
  Location: apps/common/font/data/history-{platform}.jsonl

  â€¢ Per-platform files eliminate git merge conflicts
  â€¢ Automatically tracked in dotfiles repo
  â€¢ View locations: font log
  â€¢ Auto-recreates if deleted
EOF

  else
    # Fallback for when formatting library is not available
    cat <<'EOF'
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 Font Testing & Management
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Data-driven font tracking with automatic rankings

Commands
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  current              Show currently active font
  change               Interactive font picker with previews
  apply <font>         Apply font to Ghostty/Neovim (auto-logs)
  like [message]       Like current font with optional reason
  dislike [message]    Dislike current font with optional reason
  note <message>       Add note to current font (message required)
  random               Apply random font from all available fonts
  rank                 Show fonts ranked by likes/dislikes
  log                  View complete history
  list                 List all available font families
  generate-previews    Pre-generate all preview images
  clear-cache          Clear preview cache

Examples
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  font change                         # Interactive picker
  font like "Great ligatures"         # Like with reason
  font dislike "Too wide"             # Dislike with reason
  font note "Good for prose"          # Add note
  font rank                           # See rankings
  font log                            # View history

Data Storage
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  Location: apps/common/font/data/history-{platform}.jsonl

  â€¢ Per-platform files eliminate git merge conflicts
  â€¢ Automatically tracked in dotfiles repo
  â€¢ View locations: font log
  â€¢ Auto-recreates if deleted

EOF
  fi
}

#==============================================================================
# FONT OPERATIONS
# ==============================================================================

get_current_font() {
  if [[ -f "$GHOSTTY_CONFIG" ]]; then
    grep "^font-family" "$GHOSTTY_CONFIG" | cut -d= -f2 | xargs
  else
    echo "Unknown"
  fi
}

apply_font() {
  local font="$1"

  echo "Applying font: $font"

  # Update Ghostty
  if [[ -f "$GHOSTTY_CONFIG" ]] || [[ -L "$GHOSTTY_CONFIG" ]]; then
    # Resolve symlink to get the actual file
    local ghostty_target="$GHOSTTY_CONFIG"
    if [[ -L "$GHOSTTY_CONFIG" ]]; then
      ghostty_target="$(readlink -f "$GHOSTTY_CONFIG")"
    fi

    cp "$ghostty_target" "$ghostty_target.bak"
    sed -i "s|^font-family = .*|font-family = \"${font}\"|" "$ghostty_target"
    echo "âœ“ Updated Ghostty config"
  fi

  # Update Neovim if config exists
  if [[ -f "$NVIM_FONT_CONFIG" ]] || [[ -L "$NVIM_FONT_CONFIG" ]]; then
    # Resolve symlink to get the actual file
    local nvim_target="$NVIM_FONT_CONFIG"
    if [[ -L "$NVIM_FONT_CONFIG" ]]; then
      nvim_target="$(readlink -f "$NVIM_FONT_CONFIG")"
    fi

    cp "$nvim_target" "$nvim_target.bak"
    sed -i "s|vim.o.guifont = .*|vim.o.guifont = \"${font}:h15\"|" "$nvim_target"
    echo "âœ“ Updated Neovim config"
  fi

  # Log the apply action
  log_action "apply" "$font"

  echo ""
  echo "Font applied! Restart Ghostty to see changes."
}

mark_liked() {
  local message="$*"
  local font
  font=$(get_current_font)

  if [[ "$font" == "Unknown" ]]; then
    echo "Error: No font currently configured"
    exit 1
  fi

  log_action "like" "$font" "$message"
  echo "âœ“ Liked: $font"
  [[ -n "$message" ]] && echo "  Reason: $message"
}

mark_disliked() {
  local message="$*"
  local font
  font=$(get_current_font)

  if [[ "$font" == "Unknown" ]]; then
    echo "Error: No font currently configured"
    exit 1
  fi

  log_action "dislike" "$font" "$message"
  echo "âœ“ Disliked: $font"
  [[ -n "$message" ]] && echo "  Reason: $message"
}

add_note() {
  local message="$*"
  local font
  font=$(get_current_font)

  if [[ "$font" == "Unknown" ]]; then
    echo "Error: No font currently configured"
    exit 1
  fi

  if [[ -z "$message" ]]; then
    echo "Error: Note message required"
    echo "Usage: font note <message>"
    exit 1
  fi

  log_action "note" "$font" "$message"
  echo "âœ“ Added note to: $font"
  echo "  Note: $message"
}

show_rankings() {
  local rankings
  rankings=$(get_rankings)

  if [[ -z "$rankings" ]] || [[ "$rankings" == "null" ]]; then
    echo "No font data yet. Start using fonts and marking likes/dislikes!"
    return
  fi

  echo ""
  echo "Font Rankings (by score and recent usage)"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""

  local rank=0
  while IFS= read -r line; do
    rank=$((rank + 1))
    local font=$(echo "$line" | jq -r '.font')
    local score=$(echo "$line" | jq -r '.score')
    local likes=$(echo "$line" | jq -r '.likes')
    local dislikes=$(echo "$line" | jq -r '.dislikes')
    local last_used=$(echo "$line" | jq -r '.last_used')
    local platforms=$(echo "$line" | jq -r '.platforms')

    # Format last used
    if [[ "$last_used" == "never" ]]; then
      last_used="never used"
    else
      last_used=$(date -d "$last_used" "+%b %d, %Y" 2>/dev/null || echo "$last_used")
    fi

    printf "%2d. %s\n" "$rank" "$font"
    printf "    Score: %+d (%d likes, %d dislikes)\n" "$score" "$likes" "$dislikes"
    printf "    Last used: %s\n" "$last_used"
    printf "    Platforms: %s\n" "$platforms"
    echo ""
  done <<< "$rankings"
}

show_log() {
  local history
  history=$(get_history_raw)

  if [[ -z "$history" ]]; then
    echo "No history yet. Start using fonts!"
    return
  fi

  echo ""
  echo "Font History Log"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""

  # Show log file locations
  echo "Log files:"
  for file in "$FONT_DATA_DIR"/history-*.jsonl; do
    if [[ -f "$file" ]]; then
      local platform=$(basename "$file" .jsonl | sed 's/history-//')
      local count=$(wc -l < "$file" | xargs)
      printf "  %s: %s (%d entries)\n" "$platform" "$file" "$count"
    fi
  done
  echo ""

  # Format and display with color if bat is available
  if command -v bat &>/dev/null; then
    echo "$history" | jq -r '
      "\(.ts) | \(.platform) | \(.action) | \(.font)" +
      (if .message then " | \(.message)" else "" end)
    ' | bat --plain --language=log --theme=base16
  else
    echo "$history" | jq -r '
      "\(.ts) | \(.platform) | \(.action) | \(.font)" +
      (if .message then " | \(.message)" else "" end)
    '
  fi
}

#==============================================================================
# FZF PREVIEW INTEGRATION
# ==============================================================================

change_font() {
  if ! command -v fzf &>/dev/null; then
    echo "Error: fzf not found. Install with: brew install fzf"
    exit 1
  fi

  if ! command -v magick &>/dev/null; then
    echo "Error: ImageMagick not found. Install with: brew install imagemagick"
    exit 1
  fi

  # Check for image display tool
  if ! command -v chafa &>/dev/null && ! command -v viu &>/dev/null; then
    echo "Note: Install 'chafa' or 'viu' for image preview support"
    echo "  brew install chafa"
    echo ""
    echo "Continuing with text-based preview..."
    sleep 2
  fi

  # Create cache directory
  mkdir -p "$PREVIEW_CACHE_DIR"

  # Create a simple preview script
  local preview_script="/tmp/font-fzf-preview-$$.sh"
  cat > "$preview_script" <<PREVIEW_EOF
#!/bin/bash
# Load library functions
source "$FONT_APP_DIR/lib/lib.sh"

font="\$1"

# Get or generate preview
if preview_file=\$(get_or_generate_preview "\$font" 2>/dev/null); then
  # Display it (optimized for speed)
  if command -v chafa &>/dev/null; then
    chafa -f kitty --speed 10 --dither none "\$preview_file" 2>/dev/null || echo "Preview: \$font"
  elif command -v viu &>/dev/null; then
    viu -w 80 "\$preview_file" 2>/dev/null || echo "Preview: \$font"
  else
    echo "Font: \$font"
    echo ""
    echo "(Install chafa or viu for image preview)"
  fi
else
  echo "Failed to generate preview for: \$font"
fi
PREVIEW_EOF

  chmod +x "$preview_script"

  # Run fzf
  local selected
  selected=$(list_fonts | fzf \
    --prompt="Select font > " \
    --height=100% \
    --preview="$preview_script {}" \
    --preview-window=right:80%)

  # Cleanup
  rm -f "$preview_script"

  if [[ -n "$selected" ]]; then
    apply_font "$selected"
  fi
}

random_font() {
  mapfile -t all_fonts < <(list_fonts)

  if [[ ${#all_fonts[@]} -eq 0 ]]; then
    echo "Error: No fonts found"
    exit 1
  fi

  local selected_font="${all_fonts[$RANDOM % ${#all_fonts[@]}]}"

  echo "ðŸŽ² Randomly selected: $selected_font"
  echo ""
  apply_font "$selected_font"
}

generate_all_previews() {
  echo "Pre-generating all font previews..."
  echo "This will take a few minutes but makes browsing instant."
  echo ""

  mkdir -p "$PREVIEW_CACHE_DIR"

  local total=$(list_fonts | wc -l | xargs)
  local current=0

  while IFS= read -r font; do
    current=$((current + 1))
    printf "[%d/%d] Generating preview for: %s\n" "$current" "$total" "$font"

    local cache_file=$(get_cached_preview_path "$font")

    # Skip if already exists and is valid
    if [[ -f "$cache_file" ]] && validate_preview_image "$cache_file" &>/dev/null; then
      echo "  âœ“ Already exists"
      continue
    fi

    if generate_font_preview "$font" "$cache_file" 2>/dev/null; then
      echo "  âœ“ Generated"
    else
      echo "  âœ— Failed"
    fi
  done < <(list_fonts)

  echo ""
  echo "âœ“ All previews generated!"
  echo "  Cache location: $PREVIEW_CACHE_DIR"
  echo "  Run 'font preview' for instant browsing"
}

#==============================================================================
# MAIN COMMAND DISPATCHER
# ==============================================================================

main() {
  case "${1:-}" in
    list)
      list_fonts
      ;;
    current)
      echo "Current font: $(get_current_font)"
      ;;
    change)
      change_font
      ;;
    apply)
      if [[ -z "${2:-}" ]]; then
        echo "Error: Font name required"
        usage
        exit 1
      fi
      apply_font "$2"
      ;;
    like)
      mark_liked "${@:2}"
      ;;
    dislike)
      mark_disliked "${@:2}"
      ;;
    note)
      add_note "${@:2}"
      ;;
    random)
      random_font
      ;;
    rank)
      show_rankings
      ;;
    log)
      show_log
      ;;
    generate-previews)
      generate_all_previews
      ;;
    clear-cache)
      clear_preview_cache
      ;;
    *)
      usage
      exit 1
      ;;
  esac
}

main "$@"

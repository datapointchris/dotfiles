# shellcheck shell=bash
# ================================================================== #
# BASH PROMPT CONFIGURATION
# Ported from zsh prompt.zsh - feature parity where possible
# ================================================================== #

# Disable virtualenv prompt modification (handled in custom prompt)
export VIRTUAL_ENV_DISABLE_PROMPT=1

# ================================================================== #
# COLOR SETUP
# ================================================================== #

_bash_prompt_config() {
  local ESC_OPEN="\["
  local ESC_CLOSE="\]"

  if tput setaf >/dev/null 2>&1; then
    _setaf() { tput setaf "$1"; }
    _setab() { tput setab "$1"; }
    RESET="${ESC_OPEN}$(tput sgr0)${ESC_CLOSE}"
    BOLD="$(tput bold)"
  else
    _setaf() { printf '\033[%sm' "$((30 + $1))"; }
    _setab() { printf '\033[%sm' "$((40 + $1))"; }
    RESET="${ESC_OPEN}\033[0m${ESC_CLOSE}"
    BOLD="\033[1m"
  fi

  # Standard colors (wrapped for PS1)
  C_BLACK="${ESC_OPEN}$(_setaf 0)${ESC_CLOSE}"
  C_RED="${ESC_OPEN}$(_setaf 1)${ESC_CLOSE}"
  C_GREEN="${ESC_OPEN}$(_setaf 2)${ESC_CLOSE}"
  C_YELLOW="${ESC_OPEN}$(_setaf 3)${ESC_CLOSE}"
  C_BLUE="${ESC_OPEN}$(_setaf 4)${ESC_CLOSE}"
  C_MAGENTA="${ESC_OPEN}$(_setaf 5)${ESC_CLOSE}"
  C_CYAN="${ESC_OPEN}$(_setaf 6)${ESC_CLOSE}"
  C_WHITE="${ESC_OPEN}$(_setaf 7)${ESC_CLOSE}"

  # Bright colors
  C_BRIGHT_BLACK="${ESC_OPEN}$(_setaf 8)${ESC_CLOSE}"
  C_BRIGHT_RED="${ESC_OPEN}$(_setaf 9)${ESC_CLOSE}"
  C_BRIGHT_GREEN="${ESC_OPEN}$(_setaf 10)${ESC_CLOSE}"
  C_BRIGHT_YELLOW="${ESC_OPEN}$(_setaf 11)${ESC_CLOSE}"
  C_BRIGHT_BLUE="${ESC_OPEN}$(_setaf 12)${ESC_CLOSE}"
  C_BRIGHT_MAGENTA="${ESC_OPEN}$(_setaf 13)${ESC_CLOSE}"
  C_BRIGHT_CYAN="${ESC_OPEN}$(_setaf 14)${ESC_CLOSE}"
  C_BRIGHT_WHITE="${ESC_OPEN}$(_setaf 15)${ESC_CLOSE}"

  # Bold colors
  C_WHITE_BOLD="${ESC_OPEN}${BOLD}$(_setaf 7)${ESC_CLOSE}"

  # 256 color for AWS (117 = light blue)
  C_AWS="${ESC_OPEN}\033[38;5;117m${ESC_CLOSE}"

  # Raw colors (not wrapped, for use in variables built during PROMPT_COMMAND)
  RC_RED="\033[31m"
  RC_GREEN="\033[32m"
  RC_YELLOW="\033[33m"
  RC_BLUE="\033[34m"
  RC_MAGENTA="\033[35m"
  RC_CYAN="\033[36m"
  RC_WHITE="\033[37m"
  RC_RESET="\033[0m"
  RC_AWS="\033[38;5;117m"
}

# ================================================================== #
# GIT UTILITY FUNCTIONS
# ================================================================== #

_git_repo_check() {
  git rev-parse --git-dir >/dev/null 2>&1
}

_git_current_branch() {
  git symbolic-ref --short HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null
}

# ================================================================== #
# PROMPT COMPONENT FUNCTIONS
# ================================================================== #

_prompt_venv() {
  if [[ -n "$VIRTUAL_ENV" ]]; then
    local venv_name
    venv_name=$(basename "$VIRTUAL_ENV")
    printf '%s' "${RC_YELLOW}(${venv_name})${RC_RESET} "
  fi
}

_prompt_user_info() {
  local user_color="$RC_BLUE"

  if [[ -n "$SSH_CONNECTION" ]]; then
    if [[ "$USER" == "root" ]]; then
      user_color="$RC_RED"
    else
      user_color="$RC_CYAN"
    fi
  elif [[ "$USER" == "root" ]]; then
    user_color="$RC_RED"
  fi

  printf '%s' "${user_color}${USER}@${HOSTNAME%%.*}${RC_RESET}"
}

_prompt_directory() {
  local max_length=65
  local pwd_display="${PWD/#$HOME/\~}"

  if [[ ${#pwd_display} -gt $max_length ]]; then
    # Show first 2 components ... last 3 components
    local first last_dirs
    first=$(echo "$pwd_display" | cut -d'/' -f1-2)
    last_dirs=$(echo "$pwd_display" | rev | cut -d'/' -f1-3 | rev)
    pwd_display="${first}/.../${last_dirs}"
  fi

  printf '%s' "${pwd_display}"
}

_prompt_git_info() {
  if ! _git_repo_check; then
    return
  fi

  local branch_name git_status status_output

  branch_name="$(_git_current_branch)"
  status_output="$(git status --porcelain 2>/dev/null)"

  # Nerd Font icons
  local icon_branch=$'\ue0a0'      # git branch
  local icon_untracked="󱀶"         # question file
  local icon_added=$'\uf067'       # plus
  local icon_modified=$'\uf459'    # modified file
  local icon_deleted=$'\uf068'     # minus
  local icon_renamed=$'\uf061'     # arrow
  local icon_unmerged=$'\uf071'    # warning
  local icon_clean=$'\uf00c'       # check mark
  local icon_stash=$'\uf01c'       # inbox/stash

  git_status=""

  if [[ -n "$status_output" ]]; then
    # Check for different types of changes
    echo "$status_output" | grep -q "^??" && git_status+="${RC_RED}${icon_untracked}${RC_RESET} "
    echo "$status_output" | grep -q "^A" && git_status+="${RC_GREEN}${icon_added}${RC_RESET} "
    echo "$status_output" | grep -qE "^M|^ M" && git_status+="${RC_YELLOW}${icon_modified}${RC_RESET} "
    echo "$status_output" | grep -qE "^D|^ D" && git_status+="${RC_RED}${icon_deleted}${RC_RESET} "
    echo "$status_output" | grep -q "^R" && git_status+="${RC_MAGENTA}${icon_renamed}${RC_RESET} "
    echo "$status_output" | grep -q "^UU" && git_status+="${RC_RED}${icon_unmerged}${RC_RESET} "
  else
    # Clean working directory
    git_status="${RC_GREEN}${icon_clean}${RC_RESET} "
  fi

  # Check for stashes
  if git stash list 2>/dev/null | grep -q "stash@"; then
    git_status+="${RC_BLUE}${icon_stash}${RC_RESET} "
  fi

  printf '%s' "${RC_GREEN}${icon_branch} ${branch_name}${RC_RESET} ${git_status}"
}

_prompt_git_remote_status() {
  if ! _git_repo_check; then
    return
  fi

  # Check if we have an upstream branch
  local upstream
  upstream="$(git rev-parse --abbrev-ref '@{upstream}' 2>/dev/null)"
  if [[ -z "$upstream" ]]; then
    return
  fi

  local ahead_behind behind ahead remote_status
  ahead_behind="$(git rev-list --count --left-right '@{upstream}...HEAD' 2>/dev/null)"

  if [[ -n "$ahead_behind" ]]; then
    behind="$(echo "$ahead_behind" | cut -f1)"
    ahead="$(echo "$ahead_behind" | cut -f2)"

    local icon_up=$'\uf062'    # up arrow
    local icon_down=$'\uf063'  # down arrow

    remote_status=""
    [[ "$ahead" != "0" ]] && remote_status+="${RC_GREEN}${icon_up}${ahead}${RC_RESET} "
    [[ "$behind" != "0" ]] && remote_status+="${RC_RED}${icon_down}${behind}${RC_RESET} "

    printf '%s' "$remote_status"
  fi
}

_prompt_aws_info() {
  # Skip if no AWS context is set
  if [[ -z "$AWS_PROFILE" && -z "$AWS_DEFAULT_REGION" && -z "$AWS_REGION" && -z "$AWS_ACCESS_KEY_ID" ]]; then
    return
  fi

  local aws_symbol="󰅠"
  local profile="${AWS_PROFILE:-default}"
  local region="${AWS_REGION:-${AWS_DEFAULT_REGION}}"
  local expiration=""
  local exp_time current_time time_diff hours minutes

  # Check aws-vault expiration
  if [[ -n "$AWS_SESSION_EXPIRATION" ]]; then
    if command -v gdate >/dev/null 2>&1; then
      exp_time=$(gdate -d "$AWS_SESSION_EXPIRATION" +%s 2>/dev/null)
    elif date --version >/dev/null 2>&1; then
      exp_time=$(date -d "$AWS_SESSION_EXPIRATION" +%s 2>/dev/null)
    else
      exp_time=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$AWS_SESSION_EXPIRATION" +%s 2>/dev/null)
    fi

    if [[ -n "$exp_time" ]]; then
      current_time=$(date +%s)
      time_diff=$((exp_time - current_time))
      if [[ $time_diff -gt 0 ]]; then
        hours=$((time_diff / 3600))
        minutes=$(((time_diff % 3600) / 60))
        expiration=$(printf '%dh%02dm' "$hours" "$minutes")
      else
        expiration="EXPIRED"
      fi
    fi
  fi

  # Check AWSume expiration
  if [[ -z "$expiration" && -n "$AWSUME_EXPIRATION" ]]; then
    if command -v gdate >/dev/null 2>&1; then
      exp_time=$(gdate -d "$AWSUME_EXPIRATION" +%s 2>/dev/null)
    elif date --version >/dev/null 2>&1; then
      exp_time=$(date -d "$AWSUME_EXPIRATION" +%s 2>/dev/null)
    else
      exp_time=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$AWSUME_EXPIRATION" +%s 2>/dev/null)
    fi

    if [[ -n "$exp_time" ]]; then
      current_time=$(date +%s)
      time_diff=$((exp_time - current_time))
      if [[ $time_diff -gt 0 ]]; then
        hours=$((time_diff / 3600))
        minutes=$(((time_diff % 3600) / 60))
        expiration=$(printf '%dh%02dm' "$hours" "$minutes")
      else
        expiration="EXPIRED"
      fi
    fi
  fi

  # Build the info string
  local aws_info="${RC_AWS}${aws_symbol} ${profile}"
  [[ -n "$region" ]] && aws_info+="@${region}"
  aws_info+="${RC_RESET}"

  if [[ -n "$expiration" ]]; then
    if [[ "$expiration" == "EXPIRED" ]]; then
      aws_info+=" ${RC_RED}[${expiration}]${RC_RESET}"
    else
      aws_info+=" ${RC_GREEN}[${expiration}]${RC_RESET}"
    fi
  fi

  printf '%s' " $aws_info"
}

_prompt_caret() {
  local caret="❯"
  if [[ "$USER" == "root" ]]; then
    printf '%s' "${C_RED}# ${RESET}"
  else
    printf '%s' "${C_GREEN}${caret} ${RESET}"
  fi
}

# ================================================================== #
# MAIN PROMPT COMMAND
# ================================================================== #

_bash_prompt_command() {
  local exit_code=$?
  local exit_status=""

  # Exit code indicator (shown at end of first line)
  if [[ $exit_code -ne 0 ]]; then
    exit_status=" ${RC_RED}${exit_code} ⚠️${RC_RESET}"
  fi

  # Update terminal title
  local title_pwd="${PWD/#$HOME/\~}"
  if [[ "$TERM" == xterm* ]] || [[ "$TERM" == screen* ]] || [[ "$TERM" == tmux* ]]; then
    printf '\033]0;%s\007' "$title_pwd"
  fi

  # Build the prompt components
  local venv user_info directory git_info git_remote aws_info

  venv="$(_prompt_venv)"
  user_info="$(_prompt_user_info)"
  directory="$(_prompt_directory)"
  git_info="$(_prompt_git_info)"
  git_remote="$(_prompt_git_remote_status)"
  aws_info="$(_prompt_aws_info)"

  # Two-line prompt matching zsh layout:
  # Line 1: (venv) user@host:directory  git_branch git_status  git_remote  aws_info  exit_status
  # Line 2: ❯
  PS1="\n"
  PS1+="${venv}"
  PS1+="${C_BLUE}\u${RESET}${C_WHITE}@${RESET}${C_CYAN}\h${RESET}"
  PS1+="${C_WHITE}:${RESET}"
  PS1+="${C_WHITE_BOLD}${directory}${RESET}"
  PS1+="  ${git_info}"
  PS1+="${git_remote}"
  PS1+="${aws_info}"
  PS1+="${exit_status}"
  PS1+="\n"
  PS1+="$(_prompt_caret)"
}

# ================================================================== #
# LS COLORS (matching zsh config)
# ================================================================== #

export LSCOLORS="gxfxcxdxbxegedabagacad"
export LS_COLORS="di=36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43"
export CLICOLOR=1

# GREP Colors
export GREP_COLORS='mt=40;93'

# ================================================================== #
# INITIALIZATION
# ================================================================== #

_bash_prompt_config

PROMPT_COMMAND=_bash_prompt_command

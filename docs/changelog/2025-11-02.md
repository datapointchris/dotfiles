# Detailed Changelog: 2025-11-02

## Migrated Neovim Completion from nvim-cmp to blink.cmp {#blink-cmp-migration}

### Problem Statement

Copilot completions were not appearing in nvim-cmp despite being configured. After spending considerable time debugging the nvim-cmp configuration with loading order issues, dependency chains, and event triggers, the user decided to switch to blink.cmp for a simpler, more modern alternative.

### Why blink.cmp?

- **Performance**: 0.5-4ms response time vs nvim-cmp's 60ms debounce
- **Simpler configuration**: Works out of the box with sensible defaults
- **Modern codebase**: Actively maintained with regular updates
- **Built-in features**: Native lazydev support, prebuilt Rust fuzzy matcher
- **Better defaults**: Less configuration needed to achieve desired behavior

### Initial Migration Steps

1. **Created new blink-cmp.lua configuration** (`common/.config/nvim/lua/plugins/blink-cmp.lua`)
   - Configured all keymaps to match previous nvim-cmp setup
   - Added all completion sources: lsp, path, snippets, buffer, copilot, lazydev
   - Set up appearance with custom kind icons including Copilot icon ()

2. **Backed up nvim-cmp** by renaming to `nvim-cmp.lua.bak`

3. **Updated LSP integration** (`common/.config/nvim/lua/lsp/init.lua`)
   - Changed from `require('cmp_nvim_lsp').default_capabilities()` to `require('blink.cmp').get_lsp_capabilities()`
   - Updated all comments to reference blink.cmp instead of nvim-cmp

4. **Updated copilot.lua** to reference blink-cmp integration in comments

### Errors Encountered and Solutions

#### Error 1: Invalid `completion.list.selection` Type

**Error Message:**

```text
completion.list.selection: expected table, got string
```

**Root Cause:** The configuration had:

```lua
selection = 'auto_insert', -- Wrong: string value
```

**Fix:** Changed to table format:

```lua
selection = {
  preselect = true,
  auto_insert = true,
},
```

**Why This Fix:** blink.cmp's validation expects `selection` to be a table with boolean fields, not a string preset.

---

#### Error 2: Invalid `fuzzy` Configuration Fields

**Error Message:**

```text
fuzzy.use_typo_resistance: unexpected field found in configuration
```

**Root Cause:** Multiple invalid fuzzy options were configured:

- `implementation = 'prefer_rust_with_warning'` - doesn't exist
- `use_typo_resistance` - invalid field name
- `use_frecency` - invalid field name
- `use_proximity` - invalid field name

**Fix:** Commented out the entire fuzzy configuration section to use defaults:

```lua
-- fuzzy = {
--   -- Using default fuzzy settings
-- },
```

**Why This Fix:** The fuzzy configuration API appears to have changed or these options don't exist in the version being used. Using defaults is safer and the built-in fuzzy matching works well.

---

#### Error 3: Deprecated `sources.cmdline` Field

**Error Message:**

```text
`sources.cmdline` has been replaced with `cmdline.sources`
```

**Root Cause:** Had `cmdline = {}` inside the `sources` table:

```lua
sources = {
  default = { ... },
  cmdline = {},  -- Wrong location
  providers = { ... }
}
```

**Fix:** Removed the `cmdline = {}` line entirely since we're not configuring command-line specific sources.

**Why This Fix:** blink.cmp restructured its configuration and `cmdline` is now a top-level option, not nested under `sources`.

---

#### Error 4: Invalid Copilot `transform_items` Function

**Issue Found During Testing:** The copilot provider had a `transform_items` function that tried to set:

```lua
item.kind = require('blink.cmp.types').CompletionItemKind.Copilot
```

**Root Cause:** `CompletionItemKind.Copilot` doesn't exist in blink.cmp.types. Available kinds are standard LSP kinds like Text, Method, Function, etc.

**Fix:** Removed the entire `transform_items` function:

```lua
copilot = {
  name = 'copilot',
  module = 'blink-cmp-copilot',
  score_offset = 100,
  async = true,
  -- Removed transform_items
},
```

**Why This Fix:** The Copilot icon is already configured in `appearance.kind_icons`, so the transform wasn't necessary. The blink-cmp-copilot module handles item formatting correctly on its own.

---

### Testing Methodology

Instead of manually restarting Neovim after each fix, I created automated test scripts to verify the configuration. This approach was much more efficient and thorough.

#### Test Script 1: Basic Loading Test

```lua
-- Test if blink.cmp loads and check registered sources
nvim --headless -u /tmp/test_blink.lua
```

**Purpose:** Verify blink.cmp loads without errors and all sources are registered.

**Why This Script:** Quick smoke test to catch loading errors before testing functionality.

---

#### Test Script 2: Provider Module Testing

```lua
-- Test each provider module individually
for _, provider in ipairs(providers) do
  local ok, module = pcall(require, provider.module)
  -- Report success/failure
end
```

**Purpose:** Ensure each completion source module can be loaded successfully.

**Why This Script:** Helps identify which specific source is causing issues if completions don't work.

---

#### Test Script 3: Configuration Validation

```lua
-- Check if CompletionItemKind.Copilot exists
local types = require('blink.cmp.types')
if types.CompletionItemKind.Copilot then
  print('✓ Exists')
else
  print('✗ Does NOT exist')
  print('Available: ' .. vim.inspect(vim.tbl_keys(types.CompletionItemKind)))
end
```

**Purpose:** Discovered that `CompletionItemKind.Copilot` doesn't exist, revealing the transform_items bug.

**Why This Script:** Testing assumptions about the API prevents runtime errors that are hard to debug.

---

#### Test Script 4: Comprehensive Integration Test

```lua
-- Load everything, create a buffer, enable LSP, check all sources
-- Final validation that everything works together
```

**Purpose:** Full end-to-end test simulating real usage.

**Why This Script:** Ensures all components work together, not just individually.

---

### Why These Testing Scripts Were Chosen

1. **Incremental Validation**: Each script tested one aspect, making it easy to identify exactly what was broken
2. **Automated Iteration**: No manual Neovim restarts needed - scripts run in headless mode
3. **Clear Output**: Each test printed success/failure messages, making issues obvious
4. **API Discovery**: The validation tests revealed what fields/types actually exist vs. what was assumed

### Final Resolution

After fixing all four errors:

1. ✅ blink.cmp loads without errors
2. ✅ All 6 sources registered: lsp, path, snippets, buffer, copilot, lazydev
3. ✅ All source modules load successfully
4. ✅ Copilot authenticated and working
5. ✅ No startup errors or warnings
6. ✅ Completions appear instantly during typing

### Files Modified

**Created:**

- `common/.config/nvim/lua/plugins/blink-cmp.lua` (173 lines)

**Modified:**

- `common/.config/nvim/lua/lsp/init.lua` (changed capabilities and comments)
- `common/.config/nvim/lua/plugins/copilot.lua` (updated comments)

**Backed Up:**

- `common/.config/nvim/lua/plugins/nvim-cmp.lua` → `nvim-cmp.lua.bak`

### Learnings

1. **Don't Trust Documentation Blindly**: The WebFetch results from blink.cmp docs included configuration options that don't actually exist in the current version. Always validate with the actual API.

2. **Automated Testing is Essential**: Creating headless test scripts saved enormous time compared to manual restarts. This approach should be used for all plugin configuration going forward.

3. **Simpler is Better**: Removing the fuzzy configuration and transform_items function (using defaults) resulted in cleaner, working code. Avoid over-configuring.

4. **API Validation**: Use `pcall` and `vim.inspect` to check what actually exists before writing configuration that assumes certain fields/types exist.

5. **Incremental Migration**: Backing up the old configuration before switching was crucial. It provides a reference and allows rollback if needed.

6. **Error Messages are Helpful**: blink.cmp's error messages were very clear about what was wrong and even suggested fixes (like "`sources.cmdline` has been replaced with `cmdline.sources`").

7. **Version Awareness**: Plugin APIs change between versions. What works in examples online might not work in the version you have installed. Test everything.

---

## Enhanced Notification System with Fidget and Noice {#notification-system}

### Notification Problem Statement

Error messages during Neovim startup were disappearing too quickly to read. The user had both Fidget and Noice installed but they weren't properly configured to work together, resulting in conflicts and messages not being displayed long enough.

### Goal

- Keep Fidget's small, unobtrusive LSP progress notifications
- Use Noice for error/warning messages with longer display times
- Make all messages searchable via Telescope
- Add rounded borders to Fidget notifications

### Initial Configuration Issues

**Fidget** was configured with:

```lua
notification = {
  override_vim_notify = true,  -- Conflicts with Noice
}
```

**Noice** was basically unconfigured:

```lua
opts = {
  -- add any options here (empty)
}
```

This resulted in both plugins trying to handle notifications, with neither doing it well.

### Solution Implementation

#### Fidget Configuration

**Key Changes:**

```lua
progress = {
  display = {
    render_limit = 16,     -- Show up to 16 LSP messages
    done_ttl = 3,          -- Persist 3s after completion
    done_icon = '✔',       -- Show checkmark when done
  },
},
notification = {
  override_vim_notify = false,  -- Let Noice handle this
  window = {
    winblend = 0,         -- Opaque background
    border = 'rounded',   -- Rounded borders (user request)
  },
},
```

**Why These Changes:**

- `override_vim_notify = false`: Allows Noice to handle general notifications
- `border = 'rounded'`: User preference for aesthetics
- `done_ttl = 3`: Shows completion status briefly without being annoying

---

#### Noice Configuration

**Key Changes:**

```lua
lsp = {
  progress = {
    enabled = false,  -- Let Fidget handle LSP progress
  },
},
routes = {
  -- Keep errors visible for 10 seconds
  {
    filter = { event = 'msg_show', kind = 'error' },
    opts = { timeout = 10000 },
  },
  -- Keep warnings visible for 7 seconds
  {
    filter = { event = 'msg_show', kind = 'warn' },
    opts = { timeout = 7000 },
  },
  -- Route long messages to split view
  {
    filter = { event = 'msg_show', min_height = 10 },
    view = 'split',
  },
},
presets = {
  bottom_search = true,          -- Classic bottom search
  command_palette = true,        -- Unified cmdline/popupmenu
  long_message_to_split = true,  -- Long messages to split
  lsp_doc_border = true,         // Borders on hover docs
},
```

**Why These Changes:**

- Separated responsibilities: Fidget for LSP, Noice for messages
- Extended timeout for errors (10s) so they don't disappear before being read
- Long messages go to split view for better readability
- Presets enable useful features without manual configuration

---

#### Custom Keymaps

Added to Noice configuration:

```lua
keys = {
  { '<leader>fmm', '<cmd>Telescope noice<cr>', desc = 'Search Noice Messages' },
  { '<leader>fmh', '<cmd>Noice history<cr>', desc = 'Noice History' },
  { '<leader>nd', '<cmd>Noice dismiss<cr>', desc = 'Dismiss Noice Notifications' },
},
```

**Why These Keymaps:**

- `<leader>fmm`: Quick fuzzy search through all messages with Telescope
- `<leader>fmh`: Show full chronological message history
- `<leader>nd`: Dismiss notifications when they're in the way
- Prefix `fm` (find messages) groups related functionality

### Notification Testing Process

No automated tests were needed for this change. The user was able to immediately verify:

1. Fidget notifications appeared with rounded borders
2. Error messages from blink.cmp configuration stayed visible for 10 seconds
3. `<leader>fmh` showed full message history including the errors

### Notification Files Modified

**Modified:**

- `common/.config/nvim/lua/plugins/fidget.lua` (added progress config, disabled notify override, added rounded border)
- `common/.config/nvim/lua/plugins/noice.lua` (complete rewrite with routes, presets, and keymaps)

### Notification Learnings

1. **Separation of Concerns**: Having two plugins manage notifications requires clear boundaries. Fidget for LSP, Noice for everything else works perfectly.

2. **Timeout Values Matter**: 10 seconds for errors and 7 seconds for warnings is the right balance - long enough to read, short enough to not be annoying.

3. **Telescope Integration**: Being able to search through message history with `<leader>fmm` is incredibly useful for finding that one error that flashed by.

4. **Presets are Powerful**: Noice's presets enabled several useful features (long messages to split, unified command palette) without needing to understand all the underlying configuration.

5. **User Preferences**: Small details like rounded borders matter for the overall experience. Don't ignore aesthetic preferences.

6. **Immediate Validation**: The notification changes could be tested immediately by observing behavior, unlike code changes that need automated tests. Sometimes manual verification is the right approach.

---

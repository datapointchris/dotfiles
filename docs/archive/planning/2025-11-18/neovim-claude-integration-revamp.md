# Neovim Claude Integration - Simplified Revamp Plan

**Date**: 2025-11-18
**Objective**: Strip codecompanion.nvim down to essentials, refactor to modular config, add automated testing.

---

## Key Realizations

### 1. claudecode.nvim's Actual Purpose (KEEP IT)

**What it does:**
- Creates a WebSocket server that Claude Code CLI discovers and connects to
- Lets Claude Code CLI **control** your Neovim:
  - Open files from Claude Code → they open in Neovim
  - Claude Code creates diffs → they appear in Neovim
  - Send code from Neovim → goes to Claude Code terminal
  - Keeps editor and CLI in perfect sync

**What it is NOT:**
- Not a replacement for Claude Code CLI
- Not an AI assistant itself
- Not for asking questions in Neovim

**Verdict:** This is a **BRIDGE** plugin. Keep it active for large changes via Claude Code CLI.

---

### 2. codecompanion.nvim's Current Problems

**Issues with existing config:**
- ❌ 331 lines of overengineered configuration
- ❌ Custom tools that don't work (`ripgrep_search`, `repository_analyzer`, `web_search`)
- ❌ These are redundant - Claude should do this natively via its own tools
- ❌ Crazy nested Lua tables (unreadable, unmaintainable)
- ❌ No way to test if features actually work
- ❌ Auto-generated by Claude Code without understanding actual needs

**What you actually need:**
- ✅ Open a chat buffer with Claude
- ✅ Ask questions about current buffer/selection
- ✅ Request inline edits
- ✅ See diffs and accept/reject changes
- ✅ That's it. Simple.

---

## Simplified Architecture

### Two Plugins, Clear Separation

```bash
┌─────────────────────────────────────────────────────────────┐
│                    YOUR WORKFLOW                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Small Questions/Edits         Large Multi-File Changes    │
│  (in Neovim buffer)            (terminal-based)            │
│         │                              │                    │
│         ▼                              ▼                    │
│  codecompanion.nvim            claudecode.nvim             │
│  - Chat buffer                 - WebSocket bridge          │
│  - Inline edits                - Sync Neovim ↔ Claude CLI  │
│  - Quick diffs                 - Diff integration          │
│         │                              │                    │
│         ▼                              ▼                    │
│  Anthropic API                 Claude Code CLI             │
│  (direct)                      (full tools/MCP)            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Key Insight:** codecompanion talks to Claude API directly for quick interactions. claudecode bridges Neovim to the full Claude Code CLI experience. No overlap, no confusion.

---

## The Revamp Plan

### Phase 1: Strip Down codecompanion to Essentials

**Remove:**
- All custom tools (ripgrep_search, repository_analyzer, web_search, quick_search)
- All custom slash commands (/web, /repo)
- Custom adapter configurations (use defaults)
- Memory system complexity (keep simple or remove)
- Overengineered strategy options

**Keep:**
- Chat strategy with basic settings
- Inline strategy with diff
- Default tools (Claude's built-in tools are better anyway)
- Simple keymaps

**Result:** ~50 lines of config instead of 331.

---

### Phase 2: Refactor to Modular Config

**Current Problem:**
```lua
return {
  'plugin',
  opts = {
    strategies = {
      chat = {
        adapter = 'anthropic',
        keymaps = {
          send = {
            modes = { n = '<C-s>' }
          }
        }
      }
    }
  }
}
```
This is unreadable nested hell.

**New Approach:**
```lua
-- Define config sections at top level
local chat_keymaps = {
  send = { modes = { n = '<C-s>', i = '<C-s>' }, opts = { desc = 'Send' } },
  close = { modes = { n = '<C-c>', i = '<C-c>' }, opts = { desc = 'Close' } },
}

local inline_keymaps = {
  accept = { modes = { n = 'gda' }, opts = { desc = 'Accept diff' } },
  reject = { modes = { n = 'gdr' }, opts = { desc = 'Reject diff' } },
}

local chat_window = {
  layout = 'vertical',
  position = 'right',
  width = 0.35,
  height = 0.8,
  border = 'rounded',
}

local strategies = {
  chat = {
    adapter = 'anthropic',
    keymaps = chat_keymaps,
  },
  inline = {
    adapter = 'anthropic',
    keymaps = inline_keymaps,
  },
}

local display = {
  chat = {
    window = chat_window,
    show_settings = false,
  },
  diff = {
    enabled = true,
    provider = 'mini_diff',
  },
}

-- Clean, readable return
return {
  'olimorris/codecompanion.nvim',
  enabled = true,
  cond = vim.env.NVIM_AI_ENABLED == 'true',
  dependencies = {
    'nvim-lua/plenary.nvim',
    'nvim-treesitter/nvim-treesitter',
    'echasnovski/mini.diff',
  },
  opts = {
    strategies = strategies,
    display = display,
    log_level = 'ERROR',
  },
}
```

**Benefits:**
- Readable: Can see structure at a glance
- Modular: Easy to comment out sections for testing
- Maintainable: Changes are obvious
- Debuggable: Can inspect variables in isolation

---

### Phase 3: Automated Testing Strategy

**Problem:** Hand-testing 331 lines of config is painful and error-prone.

**Solution:** Create a test script that exercises core functionality.

#### Test Script: `test-codecompanion.lua`

```lua
-- Test script for codecompanion.nvim functionality
-- Run with: nvim --headless -u test-codecompanion.lua

local function test(name, fn)
  local success, err = pcall(fn)
  if success then
    print("✅ " .. name)
  else
    print("❌ " .. name .. ": " .. tostring(err))
  end
end

print("\n=== Testing codecompanion.nvim ===\n")

-- Test 1: Plugin loads
test("Plugin loads", function()
  local ok, cc = pcall(require, 'codecompanion')
  assert(ok, "Failed to require codecompanion")
  assert(cc ~= nil, "codecompanion module is nil")
end)

-- Test 2: Commands exist
test("Commands registered", function()
  local commands = vim.api.nvim_get_commands({})
  assert(commands.CodeCompanion ~= nil, "CodeCompanion command not found")
  assert(commands.CodeCompanionChat ~= nil, "CodeCompanionChat command not found")
  assert(commands.CodeCompanionActions ~= nil, "CodeCompanionActions command not found")
end)

-- Test 3: Keymaps are set (if enabled)
test("Keymaps configured", function()
  -- Check for leader+a keymap
  local keymaps = vim.api.nvim_get_keymap('n')
  local has_leader_a = false
  for _, map in ipairs(keymaps) do
    if map.lhs and map.lhs:match('<leader>a') then
      has_leader_a = true
      break
    end
  end
  assert(has_leader_a, "Leader+a keymap not found")
end)

-- Test 4: Adapters configured
test("Anthropic adapter available", function()
  local cc = require('codecompanion')
  local adapters = require('codecompanion.adapters')
  assert(adapters.anthropic ~= nil, "Anthropic adapter not found")
end)

-- Test 5: Strategies configured
test("Chat strategy configured", function()
  local cc = require('codecompanion')
  -- Check that strategy exists in config
  assert(cc.config and cc.config.strategies, "Strategies not configured")
  assert(cc.config.strategies.chat, "Chat strategy not found")
end)

-- Test 6: Inline strategy configured
test("Inline strategy configured", function()
  local cc = require('codecompanion')
  assert(cc.config.strategies.inline, "Inline strategy not found")
end)

-- Test 7: mini.diff available
test("mini.diff integration", function()
  local ok, diff = pcall(require, 'mini.diff')
  assert(ok, "mini.diff not available")
end)

-- Test 8: API key set (warning only)
test("ANTHROPIC_API_KEY set", function()
  local key = vim.env.ANTHROPIC_API_KEY
  if not key or key == '' then
    print("   ⚠️  Warning: ANTHROPIC_API_KEY not set")
  end
end)

print("\n=== Test Summary ===")
print("Run these tests after each config change to verify functionality.")
print("To test interactively, use the manual test plan below.\n")
```

#### Running Tests

```bash
# Quick automated test (catches obvious breaks)
nvim --headless -c "luafile ~/.config/nvim/test-codecompanion.lua" -c "qa"

# Or add as a Task command
task test:codecompanion
```

#### Manual Test Checklist (Quick, 2 minutes)

After automated tests pass, verify interactivity:

```text
1. Open Neovim → Open any Lua file
2. Press <leader>a → Chat buffer opens? ✅/❌
3. Type "what is this file?" → Claude responds? ✅/❌
4. Select a function (visual) → Press <leader>cc → Type "add comments" → Diff appears? ✅/❌
5. Press gda → Changes applied? ✅/❌
6. Done. 5 tests, 2 minutes.
```

---

### Phase 4: Simplified Config Modules

#### File Structure (Proposed)

```bash
platforms/common/.config/nvim/lua/plugins/codecompanion/
├── init.lua              # Main plugin definition (imports others)
├── keymaps.lua           # All keymaps in one place
├── strategies.lua        # Chat & inline strategy configs
├── display.lua           # UI configuration
└── test.lua              # Test helpers
```

**OR** (simpler - one file approach):

```text
platforms/common/.config/nvim/lua/plugins/codecompanion.lua
# Single file, ~80 lines, modular variables at top
```

**Recommendation:** Start with single-file approach. Only split if it grows past 150 lines.

---

## Minimal Working Config (Draft)

Here's what the simplified config should look like:

```lua
-- codecompanion.nvim - Minimal, working configuration
-- Keep it simple: chat, inline edits, diffs. That's it.

-- ============================================================================
-- Keymaps (defined at top for clarity)
-- ============================================================================
local chat_keymaps = {
  send = {
    modes = { n = '<C-s>', i = '<C-s>' },
    opts = { desc = 'Send message' },
  },
  close = {
    modes = { n = '<C-c>', i = '<C-c>' },
    opts = { desc = 'Close chat' },
  },
}

local inline_keymaps = {
  accept_change = {
    modes = { n = 'gda' },
    opts = { desc = 'Accept diff' },
  },
  reject_change = {
    modes = { n = 'gdr' },
    opts = { desc = 'Reject diff' },
  },
}

-- ============================================================================
-- Strategies (chat & inline)
-- ============================================================================
local strategies = {
  chat = {
    adapter = 'anthropic',
    keymaps = chat_keymaps,
  },
  inline = {
    adapter = 'anthropic',
    keymaps = inline_keymaps,
  },
}

-- ============================================================================
-- Display (how chat looks)
-- ============================================================================
local display = {
  chat = {
    window = {
      layout = 'vertical',
      position = 'right',
      width = 0.35,
      height = 0.8,
      border = 'rounded',
    },
    show_settings = false,
  },
  diff = {
    enabled = true,
    provider = 'mini_diff',
  },
}

-- ============================================================================
-- Plugin Definition (clean!)
-- ============================================================================
return {
  {
    'olimorris/codecompanion.nvim',
    enabled = true,
    cond = vim.env.NVIM_AI_ENABLED == 'true',
    dependencies = {
      'nvim-lua/plenary.nvim',
      'nvim-treesitter/nvim-treesitter',
      'echasnovski/mini.diff',
    },
    opts = {
      strategies = strategies,
      display = display,
      log_level = 'ERROR',
    },
  },

  -- mini.diff for diff visualization
  {
    'echasnovski/mini.diff',
    config = function()
      require('mini.diff').setup({
        source = require('mini.diff').gen_source.none(), -- CodeCompanion enables when needed
      })
    end,
  },
}
```

**Line count:** ~80 lines (vs 331 original)
**Readability:** Excellent
**Maintainability:** Easy to modify
**Functionality:** Same core features, no broken custom tools

---

## Why This Works

### Claude's Built-in Capabilities (Don't Reinvent)

**You asked:** "Why custom ripgrep/web search when Claude should do this?"

**Answer:** You're 100% correct. Claude Sonnet 4.5 has built-in tools:
- **Web search** - Just ask "search the web for X" and Claude uses its web_search tool
- **File reading** - Claude can read files in your project via context
- **Code analysis** - Claude understands your codebase without custom tools

**The old config tried to:**
- Wrap `rg` in a custom tool (unnecessary)
- Create custom "repository analyzer" (Claude does this natively)
- Build custom web search (Claude has this built-in)

**Result:** Complexity that doesn't work and isn't needed.

### What codecompanion SHOULD Do (Core Features)

1. **Provide a chat interface** - Side buffer for conversations
2. **Send buffer context** - Claude sees your code automatically
3. **Handle inline edits** - Request changes, see diffs, accept/reject
4. **Connect to Claude API** - Let Claude's tools do the work

That's it. No custom tools. No slash commands. No memory system complexity.

---

## Testing Strategy

### Level 1: Automated (Catches Breakage)

Run the test script after any config change:

```bash
# Add to Taskfile
task test:codecompanion
```

This verifies:
- Plugin loads
- Commands exist
- Keymaps registered
- Adapters configured
- Strategies present
- Dependencies available

**Time:** 5 seconds
**Catches:** 80% of issues (typos, missing deps, config errors)

### Level 2: Manual Interactive (Verifies UX)

Quick 2-minute test after automated tests pass:

```text
1. Chat opens? (<leader>a)
2. Claude responds? (ask a question)
3. Inline edit works? (select code, <leader>cc, request change)
4. Diff appears? (after edit request)
5. Accept/reject works? (gda/gdr)
```

**Time:** 2 minutes
**Catches:** Remaining 20% (API issues, UX bugs, diff problems)

### Level 3: Real-World Usage (Final Check)

Use it for actual work:
- Ask about unfamiliar code
- Request a small refactor
- Have a back-and-forth conversation

**Time:** Natural during work
**Catches:** Edge cases, workflow issues

---

## Implementation Plan

### Step 1: Backup & Test Current Setup

```bash
# Backup existing config
cp platforms/common/.config/nvim/lua/plugins/codecompanion.lua \
   platforms/common/.config/nvim/lua/plugins/codecompanion.lua.backup

# Document what currently doesn't work
nvim test-results.txt
# List each feature that fails with current config
```

### Step 2: Create Test Script

```bash
# Create test file
nvim platforms/common/.config/nvim/test-codecompanion.lua
# Paste the test script from above
```

### Step 3: Replace Config with Minimal Version

```bash
# Replace codecompanion.lua with minimal config
# (We'll do this together)
```

### Step 4: Run Automated Tests

```bash
nvim --headless -c "luafile ~/.config/nvim/test-codecompanion.lua" -c "qa"
```

### Step 5: Run Manual Tests

```text
1. Open Neovim
2. Run through 5-test checklist
3. Document results
```

### Step 6: Iterate if Needed

If tests fail:
- Check logs: `:CodeCompanionLogs`
- Verify API key: `:echo $ANTHROPIC_API_KEY`
- Check adapter: `:CodeCompanionActions` → see if Anthropic listed
- Adjust config based on errors

---

## Keybinding Strategy (Avoid Conflicts)

### Current Conflict: `<leader>cc`

Both plugins use this:
- codecompanion: Inline assistant
- claudecode: Toggle terminal

**Solution:** Separate by prefix clearly

```lua
-- codecompanion.nvim (chat/inline work)
<leader>a   - Toggle chat (main interface)
<leader>cc  - Inline assistant
<leader>ca  - Action palette
ga          - Add selection to chat (visual)
gda         - Accept diff
gdr         - Reject diff

-- claudecode.nvim (bridge to CLI)
<leader>ct  - Toggle Claude Code terminal (changed from cc)
<leader>cf  - Focus Claude Code terminal
<leader>cb  - Add buffer to Claude Code
<leader>cs  - Send selection to Claude Code (visual)
```

**Change Required:**
In `claudecode.lua`, change:
```lua
-- FROM:
{ '<leader>cc', '<cmd>ClaudeCode<cr>', desc = 'Toggle Claude' },

-- TO:
{ '<leader>ct', '<cmd>ClaudeCode<cr>', desc = 'Toggle Claude terminal' },
```

Now no conflicts. `<leader>c*` is all Claude-related, but different commands.

---

## Expected Outcomes

### After Revamp

**Config:**
- ~80 lines (down from 331)
- Readable modular structure
- No broken custom tools
- Easy to test and maintain

**Functionality:**
- Chat with Claude in side buffer ✅
- Ask questions about current file ✅
- Request inline edits ✅
- See diffs, accept/reject ✅
- **All features actually work** ✅

**Testing:**
- 5-second automated test catches breakage
- 2-minute manual test verifies UX
- Confidence in config changes

**Maintainability:**
- Clear what each section does
- Easy to disable features (comment out variables)
- No mystery nested tables
- Future changes are straightforward

---

## Questions Before We Start

1. **Do you want to keep any of the custom tools/commands?**
   - My recommendation: No, remove them all. Claude's built-in tools are better.

2. **Chat window preferences:**
   - Right side vertical (current config)? OR
   - Floating window? OR
   - Bottom horizontal?

3. **Keybindings:**
   - Keep current (`<leader>a` for chat, `<leader>cc` for inline)?
   - Or different preferences?

4. **Testing approach:**
   - Create the test script as shown?
   - Add it to Taskfile for easy running?

5. **Config structure:**
   - Single file with modular variables (my recommendation)?
   - Or split into multiple files?

---

## Next Steps

Once you answer the questions above, I'll:

1. **Create the minimal config** - Clean, modular, ~80 lines
2. **Update claudecode keybinding** - Change `<leader>cc` to `<leader>ct` to avoid conflict
3. **Create test script** - Automated testing for peace of mind
4. **Update keymaps.lua** - Enable codecompanion with `companion_enabled = 'true'`
5. **Run tests** - Verify everything works
6. **Document** - Quick reference for features and testing

**Result:** A clean, working, testable codecompanion setup that you understand and can maintain.

Ready to proceed?
